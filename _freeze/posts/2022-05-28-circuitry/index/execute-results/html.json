{
  "hash": "8dbfe6404c61ac3285a36e10fe57db86",
  "result": {
    "markdown": "---\ntitle: \"Circuitry\"\ndescription: \"Generative art project based on a looped path\"\ndate: \"2022-05-28\"\ncategories: [R, Generative Art]\nimage: \"output_1.jpeg\"\nexecute: \n  eval: false\n---\n\n\n<hr>\n\n<center>\n\n<h2>Background</h2>\n\n</center>\n\n<hr>\n\nThis small generative art project uses code from my previous work. I really liked the looped path objects and decided to try something else with them. This work expands the loop a little, adds a randomly generated color scheme, and uses a standard image style.\n\n<br>\n<hr>\n\n<center>\n\n<h2>Code</h2>\n\n</center>\n\n<hr>\n\nThe first function is `get_maze`. This code creates a maze from a `size`-by-`size` grid. The final code uses a base `size` of ten. The maze starts at the bottom middle and randomly adds edges.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"[`get_maze` function]\"}\nget_maze <- function(size) {\n  \n  # Sets up base data set of potential edges for the maze\n  # size is always 5 for right now\n  edges <- CJ(\n    x1 = rep(seq(1, size), 2),\n    y1 = seq(1, size)\n  )\n  edges[, \":=\"(x2 = ifelse(.I %% 2 == 0, x1 + 1, x1),\n               y2 = ifelse(.I %% 2 == 1, y1 + 1, y1))]\n  edges <- edges[x2 <= size & y2 <= size, ]\n  edges[, id := seq(1, nrow(edges))]\n  edges[, \":=\"(node1 = (x1 - 1) * size + (y1 - 1) + 1,\n               node2 = (x2 - 1) * size + (y2 - 1) + 1)]\n  setkey(edges, id)\n  \n  # data set of nodes\n  nodes <- unique(rbind(edges[, .(id = node1)], edges[, .(id = node2)]))\n  nodes[, connected := 0]\n  setkey(nodes, id)\n  \n  # data set of node id to edge ids\n  nodes_edges <- unique(rbind(edges[, .(id = node1, edge = id)][], \n                              edges[, .(id = node2, edge = id)]))\n  setkey(nodes_edges, id)\n  \n  # location : 1 for maze, 0 for frontier, -1 for uncharted, -2 for discarded\n  # starting point : bottom middle\n  # include bottom middle then either off to the sides or up\n  starting_edge <- edges[(x1 == 3 & y1 == 1) |\n                           (x1 == 2 & y1 == 1 & x2 == 3 & y2 == 1), ][sample(.N, 1), ]\n  \n  # Set up base columns\n  edges[, \":=\"(location = -1,\n               probability = 0)]\n  edges[.(starting_edge$id), \":=\"(location = 1,\n                                  probability = 0)]\n  nodes[.(c(starting_edge$node1, starting_edge$node2)), connected := 1]\n  edges[.(nodes_edges[.(c(starting_edge$node1, starting_edge$node2)), \"edge\"]), \":=\"\n        (location = fifelse(location == -1, 0, location),\n          probability = fifelse(location == -1, 1, probability))]\n  \n  #### Loop through maze generation ----\n  num_edges <- 1\n  while (num_edges < (size^2 - 1)) {\n    \n    # select next edge\n    selected_edge <- edges[sample(.N, 1, prob = probability), ]\n    \n    ## if it's good, then\n    # add it to the maze\n    # add connecting edges to the frontier\n    # else add it to discard\n    if (any(nodes[.(c(selected_edge$node1, selected_edge$node2))\n                  , connected] == 0)) {\n      \n      # add to maze\n      edges[.(selected_edge$id), \":=\"(location = 1,\n                                      probability = 0)]\n      \n      # update nodes\n      nodes[.(c(selected_edge$node1, selected_edge$node2)), connected := 1]\n      \n      # update frontier\n      edges[.(nodes_edges[.(c(selected_edge$node1, selected_edge$node2))\n                          , \"edge\"]), \":=\"\n            (location = fifelse(location == -1, 0, location),\n              probability = fifelse(location == -1, 1, probability))]\n      \n      num_edges <- num_edges + 1\n    } else {\n      # drop from frontier\n      edges[.(selected_edge$id), \":=\"(location = -2,\n                                      probability = 0)]\n    }\n  }\n  \n  return(edges[location == 1, ])\n}\n```\n:::\n\n\nThe next function, `update_maze`, doubles the edges so that the maze follows a loop. The new connections trace the outline of the maze. This action mimics exploring the maze and following the path back to the start.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"[`update_maze` function]\"}\nupdate_maze <- function(edges) {\n  \n  # list out all possible edges\n  # (basically same code as setting up the maze)\n  # plus adds edges that stick out on the outside\n  size <- max(edges$x1) + 1\n  all_possible_edges <- CJ(\n    x1 = rep(seq(1, size), 2) - 1,\n    y1 = seq(1, size) - 1\n  )\n  all_possible_edges[, \":=\"(x2 = ifelse(.I %% 2 == 0, x1 + 1, x1),\n                            y2 = ifelse(.I %% 2 == 1, y1 + 1, y1))]\n  all_possible_edges <- all_possible_edges[(x1 != 0 | x2 != 0) &\n                                             (y1 != 0 | y2 != 0), ]\n  \n  edges <- edges[, .(x1, x2, y1, y2, id)]\n  \n  # merge maze and all possible edges to see which ones weren't used\n  all_possible_edges <- merge(all_possible_edges, edges,\n                              by = c(\"x1\", \"y1\", \"x2\", \"y2\"),\n                              all.x = TRUE\n  )\n  \n  # This function subs in the new edges appropriately\n  # basically, any path edge needs to be updated to two edges so the maze\n  # starts at the bottom middle, travels through the maze, and back to the start\n  create_new_edges <- function(x1, y1, x2, y2, id) {\n    # if no edges, add block\n    if (is.na(id)) {\n      if (y1 == y2) { # horizontal edge\n        list(\n          x1_1 = 2 * x1,\n          y1_1 = 2 * y1 - 1,\n          x2_1 = 2 * x1,\n          y2_1 = 2 * y1,\n          x1_2 = 2 * x2 - 1,\n          y1_2 = 2 * y2 - 1,\n          x2_2 = 2 * x2 - 1,\n          y2_2 = 2 * y2\n        )\n      } else { # vertical edge\n        list(\n          x1_1 = 2 * x1 - 1,\n          y1_1 = 2 * y1,\n          x2_1 = 2 * x1,\n          y2_1 = 2 * y1,\n          x1_2 = 2 * x2 - 1,\n          y1_2 = 2 * y2 - 1,\n          x2_2 = 2 * x2,\n          y2_2 = 2 * y2 - 1\n        )\n      }\n    } else { # has edge, add connections\n      if (y1 == y2) { # horizontal edge\n        list(\n          x1_1 = 2 * x1,\n          y1_1 = 2 * y1 - 1,\n          x2_1 = 2 * x2 - 1,\n          y2_1 = 2 * y2 - 1,\n          x1_2 = 2 * x1,\n          y1_2 = 2 * y1,\n          x2_2 = 2 * x2 - 1,\n          y2_2 = 2 * y2\n        )\n      } else { # vertical edge\n        list(\n          x1_1 = 2 * x1 - 1,\n          y1_1 = 2 * y1,\n          x2_1 = 2 * x2 - 1,\n          y2_1 = 2 * y2 - 1,\n          x1_2 = 2 * x1,\n          y1_2 = 2 * y1,\n          x2_2 = 2 * x2,\n          y2_2 = 2 * y2 - 1\n        )\n      }\n    }\n  }\n  \n  # fill in blocks and paths\n  all_possible_edges[, c(\n    \"x1_1\", \"y1_1\", \"x2_1\", \"y2_1\",\n    \"x1_2\", \"y1_2\", \"x2_2\", \"y2_2\"\n  ) := create_new_edges(x1, y1, x2, y2, id),\n  by = seq_len(nrow(all_possible_edges))\n  ]\n  \n  # clean everything up\n  all_possible_edges[, \":=\"(x1 = NULL,\n                            y1 = NULL,\n                            x2 = NULL,\n                            y2 = NULL,\n                            id = NULL)]\n  \n  all_possible_edges <- melt(all_possible_edges,\n                             measure.vars = patterns(\"x1\", \"y1\", \"x2\", \"y2\"),\n                             value.name = c(\"x1\", \"y1\", \"x2\", \"y2\")\n  )[, variable := NULL]\n  \n  all_possible_edges <- all_possible_edges[(x1 > 0 &\n                                              y1 > 0 &\n                                              x2 < (2 * size - 1) &\n                                              y2 < (2 * size - 1)), ]\n}\n```\n:::\n\n\nThe last external function, `maze_to_path`, puts all the edges in order from the bottom left corner, traveling through the loop and back to the beginning.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"[`maze_to_path` function]\"}\nmaze_to_path <- function(edges) {\n  # set up id\n  edges[, id := .I]\n  setkey(edges, id)\n  \n  # set up nodes data set\n  nodes <- unique(rbind(edges[, .(x = x1, y = y1)]\n                        , edges[, .(x = x2, y = y2)]))\n  nodes[, id := .I]\n  setkey(nodes, id)\n  \n  # add node ids to edges data set\n  edges <- merge(edges, nodes,\n                 by.x = c(\"x1\", \"y1\"), by.y = c(\"x\", \"y\"),\n                 suffixes = c(\"\", \"_node_1\"), all.x = TRUE\n  )\n  edges <- merge(edges, nodes,\n                 by.x = c(\"x2\", \"y2\"), by.y = c(\"x\", \"y\"),\n                 suffixes = c(\"\", \"_node_2\"), all.x = TRUE\n  )\n  \n  # nodes to edges look up table\n  nodes_edges <- unique(rbind(\n    edges[, .(id = id_node_1, edge = id, connecting_node = id_node_2)],\n    edges[, .(id = id_node_2, edge = id, connecting_node = id_node_1)]\n  ))\n  setkey(nodes_edges, id)\n  \n  # save spot for path\n  path <- vector(mode = \"numeric\")\n  \n  # variables to keep track of progress through the maze\n  current_node <- nodes[y == 1 & x == 1, id]\n  first_node <- current_node\n  \n  # update path\n  path <- append(path, current_node)\n  previous_node <- current_node\n  \n  # keep going to unexplored nodes\n  current_node <- nodes_edges[.(current_node), \n  ][connecting_node != previous_node\n    , connecting_node][1]\n  \n  # continue through the whole path\n  while (current_node != first_node) {\n    path <- append(path, current_node)\n    future_node <- nodes_edges[.(current_node), \n    ][connecting_node != previous_node\n      , connecting_node]\n    previous_node <- current_node\n    current_node <- future_node\n  }\n  \n  path <- data.table(\n    order = seq(1, length(path)),\n    node = path\n  )\n  path <- merge(path, nodes, by.x = c(\"node\"), by.y = c(\"id\"))\n}\n```\n:::\n\n\nThe main workhorse utilizes the previous functions to get a set of connections.\n\nThe color scheme code follows a random circle in the HCL color space. There are ten points equidistant around the circle. Sometimes the first random circle will produce invalid color values. So the code loops until it finds a complete set. The circle's center is saved and used as a border for the images and fills small circles where the connections meet.\n\nFinally, a sine wave with a random number of waves determines the connections' sizes.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"[`generate_output` code]\"}\nlibrary(data.table)\nlibrary(ggplot2)\n\nsource(\"get_maze.R\")\nsource(\"update_maze.R\")\nsource(\"maze_to_path.R\")\n\nget_set <- function(size) {\n  set <- get_maze(size)\n  set <- update_maze(set)\n  set <- maze_to_path(set)\n  \n  set[, \":=\"(x = x - (size + .5),\n             y = y - (size + .5))]\n  \n  set <- set[order(order), ]\n  set[, ':=' (xend = shift(x, type = \"lead\", fill = 1 - (size + .5) ),\n              yend = shift(y, type = \"lead\", fill = 1 - (size + .5) ))]\n}\n\n# Get color scheme by finding a random circle in HCL color space\nget_colors <- function() {\n  \n  # two random vectors\n  v1 <- runif(3, -1, 1)\n  v2 <- runif(3, -1, 1)\n  # orthogonal\n  v2 <- v2 - c(v1 %*% v2 / v1 %*% v1 ) * v1\n  # unit\n  v1 <- v1 / sqrt(c(v1 %*% v1))\n  v2 <- v2 / sqrt(c(v2 %*% v2))\n  \n  # random point\n  p <- runif(3, -30, 30) + c(0, 0, 50)\n  \n  # random radius\n  r <- runif(1, 10, 30)\n  \n  # ten points around the circle\n  # need to keep both end points even though they're the same value\n  # for scale_color_gradientn to loop back around\n  t <- seq(0, 2 * pi, length.out = 11)\n  \n  colors <- data.table(p1 = p[1],\n                       p2 = p[2],\n                       p3 = p[3],\n                       r = r,\n                       t = t,\n                       v11 = v1[1],\n                       v12 = v1[2],\n                       v13 = v1[3],\n                       v21 = v2[1],\n                       v22 = v2[2],\n                       v23 = v2[3])\n  \n  colors[, ':=' (x = p1 + r * cos(t) * v11 + r * sin(t) * v21,\n                 y = p2 + r * cos(t) * v12 + r * sin(t) * v22,\n                 z = p3 + r * cos(t) * v13 + r * sin(t) * v23)]\n  colors[, \":=\" (H = (atan2(y, x) * 180/pi) %% 360,\n                 C = sqrt(x^2 + y^2),\n                 L = z)]\n  \n  \n  colors[, ':=' (hex_value = ifelse(L < 0 | L > 100, NA_character_, \n                                    hcl(H, C, L, fixup = FALSE))), \n         by = seq_len(nrow(colors))]\n\n  return(colors)\n}\n\n# Sometimes the circle will be out of range,\n# so try again until all the colors are valid\nget_color_scheme <- function() {\n  colors <- get_colors()\n\n  while(any(is.na(colors$hex_value))) {\n    colors <- get_colors()\n  }\n  \n  return(colors)\n}\n\n# Create 10 outputs\nset.seed(10101010)\nfor(i in 1:10) {\n  size <- 10\n  set <- get_set(size)\n  \n  colors <- get_color_scheme()\n  \n  # Save center of the circle\n  color_center <- hcl(h = (atan2(colors$p2[1], colors$p1[1]) * 180/pi) %% 360,\n                      c = sqrt(colors$p1[1]^2 + colors$p2[1]^2),\n                      l = colors$p3[1])\n  \n  color_scheme <- colors[[\"hex_value\"]]\n  \n  # Get boundaries of white background square\n  boundaries <- data.table(x = c(min(set$x), max(set$x), max(set$x), min(set$x)),\n                           y = c(min(set$y), min(set$y), max(set$y), max(set$y)))\n  boundaries[, ':=' (x = x * 1.1,\n                     y = y * 1.1)]\n  \n  # Set up connections size\n  # order goes from 1 to 400\n  # 400 / waves = num segments per wave\n  waves <- round(runif(1, 70, 130))\n  offset <- runif(1, 0, 2*pi)\n  set[, size := order / max(order) * 2*pi]\n  set[, size := (sin(waves * size + offset) + 1) * 2.5 ]\n  \n  ggplot() +\n    geom_polygon(data = boundaries,\n                 aes(x, y),\n                 color = \"white\",\n                 fill = \"white\") +\n    geom_segment(data = set,\n                 aes(x, y,\n                     xend = xend, yend = yend, \n                     color = order, size = size),\n                 alpha = .5,\n                 lineend = \"round\") +\n    geom_segment(data = set,\n                 aes(x, y,\n                     xend = xend, yend = yend, \n                     color = order, size = size / 5),\n                 alpha = 1,\n                 lineend = \"round\") +\n    geom_point(data = set,\n               aes(x, y), \n               color = color_center,\n               size = .5) +\n    scale_color_gradientn(colours = color_scheme) +\n    theme_void() +\n    theme(legend.position = \"none\") +\n    coord_equal()\n  ggsave(paste0(\"output/output_\", i, \".jpeg\"), height = 5, width = 5, bg = color_center)\n}\n```\n:::\n\n\n<br>\n<hr>\n\n<center>\n\n<h2>Output</h2>\n\n</center>\n\n<hr>\n\n::: {layout-ncol=\"2\"}\n![Output 1](output_1.jpeg)\n\n![Output 2](output_2.jpeg)\n\n![Output 3](output_3.jpeg)\n\n![Output 4](output_4.jpeg)\n\n![Output 5](output_5.jpeg)\n\n![Output 6](output_6.jpeg)\n\n![Output 7](output_7.jpeg)\n\n![Output 8](output_8.jpeg)\n\n![Output 9](output_9.jpeg)\n\n![Output 10](output_10.jpeg)\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}