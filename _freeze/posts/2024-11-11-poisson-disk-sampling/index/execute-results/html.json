{
  "hash": "bf9bcefe48796bba87badfcf7cfb73db",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Poisson Disk Sampling\"\ndescription: \"Roughly evenly-spaced repeating points\"\ndate: \"2024-11-11\"\ncategories: [Python, Generative Art]\nimage: \"base_img.png\"\nexecute: \n  eval: false\n---\n\n\n<hr>\n<center>\n<h2>Introduction</h2>\n</center>\n<hr>\n\nThis post goes through the code for a Python Poisson Disk Sampling package. The code comes from [Robert Bridson's algorithm](https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf). The posts from [Sighack](https://sighack.com/post/poisson-disk-sampling-bridsons-algorithm) and [Jason Davies](https://www.jasondavies.com/poisson-disc/) are also helpful resources to have.\n\nBasically, we'll start with one point then add another point within certain bounds from that one. We'll continue adding new points off of these points and so on as long as the new points aren't too close to any other point. When no new points can be added, the algorithm is done.\n\nThe points in this code will form a repeating pattern if allowed.\n\n<br>\n<hr>\n<center>\n<h2>Code</h2>\n</center>\n<hr>\n\nWe'll start by importing the libraries.\n\n::: {#abdbc987 .cell execution_count=1}\n``` {.python .cell-code}\nimport math\nimport random\nimport copy\n```\n:::\n\n\nThen we'll create a `Point` class. It's basically just a holder for the location of a single point.\n\n::: {#5b28c184 .cell execution_count=2}\n``` {.python .cell-code}\nclass Point:\n    \"\"\"\n    Class for a singluar point\n\n    Attributes\n    ----------\n    order: int\n        The order the point was inserted into the class list\n    x: float\n        x-location of the point\n    y: float\n        y-location of the point\n\n    \"\"\"\n\n    def __init__(self,\n                 order: int,\n                 x: float,\n                 y: float) -> None:\n        \"\"\"\n        Constructs a point\n\n        Parameters\n        ----------\n        order: int\n            The order the point was inserted into the class list\n        x: float\n            x-location of the point\n        y: float\n            y-location of the point\n        \"\"\"\n        self.order = order\n        self.x = x\n        self.y = y\n\n    def __repr__(self) -> str:\n        \"\"\"repr for Point class\"\"\"\n        return f'Point(order={self.order}, x={self.x}, y={self.y})'\n\n    def __str__(self) -> str:\n        \"\"\"str for Point class\"\"\"\n        return f'{self.order}: {self.x}, {self.y}'\n\n    def point_information(self) -> list:\n        \"\"\"Returns the Point information as a list\"\"\"\n        return [self.order, self.x, self.y]\n```\n:::\n\n\nNow, we'll start to build up the main code section. First is the `PoissonDiskSampling` class. This will hold the main code for the algorithm. We'll start out with the `__init__` method to set up the basic attributes. \n\nWe'll need to keep track of:\n\n- `radius` to know how far to search around a point. This determines how close points are together.\n- `grid_height` and `grid_width` to know how big of an area to fill.\n- `sample_limit` to know when to stop trying for new points. This can affect how filled in the area gets.\n- `seed` to make it reproducible.\n- `initial_point` for an optional starting point.\n\nThese attributes will be used to build the backgroud grid, `grid`. This is used to speed up comparing a potential point to the current list of accepted points, `points`. Finally, there will be a very similar list of points that are kept to anchor potential points, `active_list`.\n\n::: {#5cdecab8 .cell execution_count=3}\n``` {.python .cell-code}\nclass PoissonDiskSampling:\n    \"\"\"\n    Class for poisson disk sampling points\n\n    Attributes\n    ----------\n    points: list\n        The main list of points\n    \"\"\"\n    def __init__(self,\n                 radius: float,\n                 grid_width: float,\n                 grid_height: float,\n                 sample_limit: int = 30,\n                 seed: int = None,\n                 inital_point: Point = None) -> None:\n        \"\"\"\n        Constructor for the poisson disk sample\n\n        Parameters\n        ----------\n        radius: float\n            The minimum distance between points\n        grid_width: float\n            The width of the grid\n        grid_height: float\n            The height of the grid\n        sample_limit: int\n            The number of times to try to find a new sample point for\n            each attempt with an active point. Decreasing will speed up\n            the process, but increasing will fill in more points.\n        seed: int\n            Seed for the random number generator, if needed.\n        inital_point: Point\n            Inital point to use. If one is not provided, then one is\n            choosen at random. This is mostly used for testing.\n        \"\"\"\n        self.radius = radius\n        self.grid_width = grid_width\n        self.grid_height = grid_height\n        self.sample_limit = sample_limit\n\n        # These are called often in the code. So they are pre-calculated\n        self.cell_size: float = self.radius / math.sqrt(2)\n        self.bounds: int = math.ceil(self.radius/self.cell_size)  # 2\n        self.wrap_cutoff = self.bounds*2\n        self.grid_cell_width: int = math.ceil(\n            self.grid_width / self.cell_size)\n        self.grid_cell_height: int = math.ceil(\n            self.grid_height / self.cell_size)\n        self.radius_2: float = (self.radius)**2\n\n        # These hold the points, one as a list and one as a 2d array.\n        # The grid has room to hold duplicated points on the edges to\n        # allow checking for point distance when the pattern repeats.\n        self.points: list[list] = []\n        self.grid: list[list] = [\n            [None for i in range(self.grid_cell_height + self.bounds*2)]\n            for j in range(self.grid_cell_width + self.bounds*2)]\n\n        # This is list of point to sample from until they are checked\n        #  for the self.sample_limit attribute\n        self.active_list: list = []\n```\n:::\n\n\nWe can finish up the rest of the `__init__` method that will sample all the points. It starts by determining the first point. Then uses a while loop to sample new points until all of the accepted points have been checked.\n\n::: {#0e401f20 .cell execution_count=4}\n``` {.python .cell-code}\n        # Set up the start\n        if seed is not None:\n            random.seed(seed)\n\n        if inital_point is not None:\n            self.insert_point(inital_point)\n        else:\n            self.insert_point(\n                Point(0,\n                      random.random() * self.grid_width,\n                      random.random() * self.grid_height))\n\n        # Continue until all points are checked\n        # Randomly pull a point that hasn't been removed each time\n        while self.active_list:\n            self.sample(random.randrange(len(self.active_list)))\n```\n:::\n\n\nIn the previous code block, the `sample` method is called in a while loop. We'll now build up two other methods, `insert_point` and `check_neighbors`, to then get to `sample`.\n\nThe `insert_point` method takes a new point and inserts it into the `grid` and `points` list. The main difficulty is in checking the edges to have points repeat if needed.\n\n::: {#b622cf71 .cell execution_count=5}\n``` {.python .cell-code}\n    def insert_point(self,\n                     p: Point) -> None:\n        \"\"\"\n        Inserts a new point into the self.points list and the self.grid\n        array. If the point is near the edge, extra points will be added\n        to the grid so the pattern can repeat itself without having\n        points too close to each other.\n        \"\"\"\n        cell_x: int = math.floor(p.x/self.cell_size) + self.bounds\n        cell_y: int = math.floor(p.y/self.cell_size) + self.bounds\n\n        self.grid[cell_x][cell_y] = p\n        self.points.append(p.point_information())\n\n        # If on the edges, loop around\n        # Check along sides\n        flip_x: bool = False\n        cell_x_wrap: int\n        x_wrap: float\n        if cell_x < self.wrap_cutoff:\n            flip_x = True\n            cell_x_wrap = self.grid_cell_width + cell_x\n            x_wrap = p.x + self.grid_width\n        elif cell_x >= self.grid_cell_width:\n            flip_x = True\n            cell_x_wrap = cell_x - self.grid_cell_width\n            x_wrap = p.x - self.grid_width\n\n        if flip_x:\n            self.grid[cell_x_wrap][cell_y] = Point(p.order, x_wrap, p.y)\n\n        # Check along top and bottom\n        flip_y: bool = False\n        cell_y_wrap: int\n        y_wrap: float\n        if cell_y < self.wrap_cutoff:\n            flip_y = True\n            cell_y_wrap = self.grid_cell_height + cell_y\n            y_wrap = p.y + self.grid_height\n        elif cell_y >= self.grid_cell_height:\n            flip_y = True\n            cell_y_wrap = cell_y - self.grid_cell_height\n            y_wrap = p.y - self.grid_height\n\n        if flip_y:\n            self.grid[cell_x][cell_y_wrap] = Point(p.order, p.x, y_wrap)\n\n        # Check corners\n        if flip_x and flip_y:\n            self.grid[cell_x_wrap][cell_y_wrap] = Point(\n                p.order, x_wrap, y_wrap)\n\n        # Insert into active list\n        self.active_list.append(p)\n```\n:::\n\n\nThe `check_neighbors` method uses the `grid` to see if the new points is too close to any other points.\n\n::: {#83a25ddb .cell execution_count=6}\n``` {.python .cell-code}\n    def check_neighbors(self,\n                        x: float,\n                        y: float) -> bool:\n        \"\"\"Checks if there are any points too close a location.\"\"\"\n        cell_x: int = math.floor(x/self.cell_size) + self.bounds\n        cell_y: int = math.floor(y/self.cell_size) + self.bounds\n\n        column: int\n        row: int\n        for column in range(cell_x - 2, cell_x + 3):\n            for row in range(cell_y - 2, cell_y + 3):\n                neighbor: Point | None = self.grid[column][row]\n                if neighbor:\n                    dx: float = neighbor.x - x\n                    dy: float = neighbor.y - y\n                    if (dx**2 + dy**2) < self.radius_2:\n                        return False\n\n        return True\n```\n:::\n\n\nThe `sample` method takes in an index for a point from the `active_list`, pulls a new point around that point, and then checks to see if it's good with `check_neighbors`. If it is good, then it calls `insert_point`. If enough attempts are made without adding a new point, the first point is removed from `active_list`.\n\nFinally, the `sample_points` method pulls everything together and repeated the points pattern if requested.\n\n::: {#b93f10fb .cell execution_count=7}\n``` {.python .cell-code}\ndef sample_points(radius: float,\n                  grid_width: float,\n                  grid_height: float,\n                  sample_limit: int = 30,\n                  repeat_percentage: float = .25,\n                  seed: int = None,\n                  inital_point: Point = None) -> None:\n    \"\"\"\n    Creates a list of points from poisson disk sampling with optional\n    repeats along the edges.\n\n    Parameters\n    ----------\n    radius: float\n        The minimum distance between points\n    grid_width: float\n        The width of the grid\n    grid_height: float\n        The height of the grid\n    sample_limit: int\n        The number of times to try to find a new sample point for\n        each attempt with an active point. Decreasing will speed up\n        the process, but increasing will fill in more points.\n    repeat_percentage: float\n        How much to repeat points around the borders. 0 for no repeats\n        1 for full repeats.\n    seed: int\n        Seed for the random number generator, if needed.\n    inital_point: Point\n        Inital point to use. If one is not provided, then one is\n        choosen at random. This is mostly used for testing.\n    \"\"\"\n    samp: PoissonDiskSampling = PoissonDiskSampling(radius=radius,\n                                                    grid_width=grid_width,\n                                                    grid_height=grid_height,\n                                                    sample_limit=sample_limit,\n                                                    seed=seed,\n                                                    inital_point=inital_point)\n    if repeat_percentage == 0:\n        return samp.points\n\n    # Find boundaries from repeat_percentage\n    width_min: float = 0 - (grid_width * repeat_percentage)\n    width_max: float = grid_width + (grid_width * repeat_percentage)\n    height_min: float = 0 - (grid_height * repeat_percentage)\n    height_max: float = grid_height + (grid_height * repeat_percentage)\n\n    # Fill list with base points and copies for repetition\n    points: list = copy.deepcopy(samp.points)\n\n    column: int\n    row: int\n    p: list\n    for column in range(-1, 2):\n        for row in range(-1, 2):\n            if column != 0 or row != 0:\n                rep_points: list = copy.deepcopy(samp.points)\n                for p in rep_points:\n                    p[1] = p[1] + column * grid_width\n                    p[2] = p[2] + row * grid_height\n                # Check if the repeated points are in bounds\n                rep_points = [p for p in rep_points\n                              if p[1] >= width_min\n                              and p[1] <= width_max\n                              and p[2] >= height_min\n                              and p[2] <= height_max]\n                points.extend(rep_points)\n\n    return points\n```\n:::\n\n\nA package for the code can be found [here](https://github.com/WilliamTylerBradley/poisson_disk_sampling).\n\n::: {#d32a4d10 .cell execution_count=8}\n``` {.python .cell-code}\n# install the package\npip install git+https://github.com/WilliamTylerBradley/poisson_disk_sampling\n```\n:::\n\n\nHere's some example code. The repetition of points is visible here.\n\n::: {#c697d0ce .cell execution_count=9}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport PoissonDiskSampling as pds\n\nheight = 20\nwidth = 20\nradius = 2\n\nsamp = pds.sample_points(radius, width, height, seed=0)\npoints = np.array(samp)\n\nfig, ax = plt.subplots()\nax.scatter(points[:, 1], points[:, 2])\nax.set_aspect('equal')\nplt.show()\n```\n:::\n\n\n![Example](base_img.png)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}