{
  "hash": "ef839a9370c7587af57b4d839d1e0d2f",
  "result": {
    "markdown": "---\ntitle: \"Choosing Nearby Colors Part 2\"\ndescription: \"Follow-up from previous post using the HCL coordinates directly\"\ndate: \"2021-08-10\"\ncategories: [R, Generative Art]\nimage: \"hcl_par_per.jpeg\"\nexecute: \n  eval: false\n---\n\n\nThis blog post follows up on the previous one. Code in that post finds colors in the HCL color space by sampling points from a sphere centered on a base point. There's a mismatch between how the sphere is determined (Cartesian coordinates of x, y, L) and the colors are parameterized (polar coordinates of H, C, L), so a conversion happens in the code.\n\nThis post looks into what happens if you just start with a \"sphere\" based on Hue, Chroma, Luminance values. So we'll set up shapes that expand out from the base point along Hue, Chroma, and Luminance directly.[^1]\n\n[^1]: If you understand the difference between polar and Cartesian coordinates pretty well, this blog post will be obvious to you. But I'm bad at math and needed to see a lot of graphs to understand what was happening. So I figured I'd throw this in a blog post.\n\n<br>\n<hr>\n<center><h2>Base Point Location</h2></center>\n<hr>\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"[A Lot of Setup Code]\"}\n##---------\n# Libraries\n##---------\nlibrary(tidyverse)\nlibrary(patchwork)\nlibrary(colorspace)\n\n##------------\n# Pick a color\n##------------\nH_point <- 322\nC_point <- 26\nL_point <- 69\n\ncolor_hex <- hcl(H_point, \n                 C_point, \n                 L_point,\n                 fixup = FALSE)\n\n##--------------------------------\n# See color in H, C, L color space \n##--------------------------------\n# C-L Plane ----\nget_C_L_plane <- function(H_point) {\n  expand_grid(H = H_point,\n              C = seq(0, 180, .5),\n              L = seq(1, 100, .5)) %>%\n    mutate(color_value = hcl(H, C, L, fixup = FALSE)) %>%\n    filter(!is.na(color_value))\n}\nC_L_plane <- get_C_L_plane(H_point)\n\ngraph_C_L_plane <- function(C_L_plane, color_hex) {\n  ggplot() +\n    geom_point(data = C_L_plane,\n               aes(C, L, color = color_value, fill = color_value)) +\n    scale_x_continuous(labels = abs) +\n    scale_color_identity() +\n    scale_fill_identity() +\n    geom_point(aes(x = C_point,\n                   y = L_point),\n               color = 'black',\n               fill = color_hex,\n               shape = 21,\n               size = 2) +\n    coord_equal()\n}\ngraph_C_L_plane(C_L_plane, color_hex)\n\n# H-L Curve ----\nget_H_L_curve <- function(C_point) {\n  expand_grid(H = seq(1, 360, 1),\n              C = C_point,\n              L = seq(1, 100, .5)) %>%\n    mutate(color_value = hcl(H, C, L, fixup = FALSE)) %>%\n    filter(!is.na(color_value))\n}\nH_L_curve <- get_H_L_curve(C_point)\n\nlabel_H_center <- function(H_point, ...) {\n  function(x) {(x + (180 - H_point)) %% 360}\n}\n\ngraph_H_L_curve <- function(H_L_curve, color_hex, H_point) {\n  ggplot() +\n    geom_point(data = H_L_curve,\n               aes((H + (180 - H_point)) %% 360, L, \n                   color = color_value, fill = color_value)) +\n    scale_color_identity() +\n    scale_fill_identity() +\n    geom_point(aes(x = 180, # Because we rotated points to not drop over edge\n                   y = L_point),\n               color = 'black',\n               fill = color_hex,\n               shape = 21,\n               size = 2) +\n    scale_x_reverse('H', # Like you're standing on the inside\n                    labels = label_H_center(H_point = H_point),\n                    limits = c(360, 0)) +\n    coord_equal()\n}\ngraph_H_L_curve(H_L_curve, color_hex, H_point)\n\n# H-C plane ----\nget_H_C_plane <- function(L_point){\n  expand_grid(H = seq(1, 360, 1),\n              C = seq(0, 180, .5),\n              L = L_point) %>%\n    mutate(color_value = hcl(H, C, L, fixup = FALSE)) %>%\n    filter(!is.na(color_value))\n}\nH_C_plane <- get_H_C_plane(L_point)\n\ngraph_H_C_plane <- function(H_C_plane, color_hex) {\n  ggplot() +\n    geom_point(data = H_C_plane,\n               aes(H, C, color = color_value, fill = color_value)) +\n    scale_color_identity() +\n    scale_fill_identity() +\n    scale_x_continuous(breaks = seq(45, 360, 45),\n                       minor_breaks = seq(0, 315, 45) + 45/2,\n                       labels = c('45', '90', '135', '180', \n                                  '225', '270', '315', '0|360')) +\n    scale_y_continuous(limits = c(0, 180)) +\n    geom_point(aes(x = H_point,\n                   y = C_point),\n               color = 'black',\n               fill = color_hex,\n               shape = 21,\n               size = 2) +\n    coord_polar(start = 270 * pi / 180,\n                direction = -1)\n}\ngraph_H_C_plane(H_C_plane, color_hex)\n\n# C tangent plane ----\nC_circle <- data.frame(H = seq(1, 360),\n                       C = C_point,\n                       color_value = \"white\")\nC_tangent_plane <- expand_grid(x = C_point, # Plane perpendicular to H at C\n                               perpendicular_from_C_L = \n                                 seq(-sqrt(180^2 - C_point^2), sqrt(180^2 - C_point^2)),\n                               L = seq(1, 100, 1)) %>%\n  mutate(x_rotate = x * cos(H_point * pi/180) -  # rotate\n           perpendicular_from_C_L * sin(H_point * pi/180),\n         y_rotate = x * sin(H_point * pi/180) + \n           perpendicular_from_C_L * cos(H_point * pi/180)) %>%\n  mutate(x = x_rotate,\n         y = y_rotate) %>%\n  select(-x_rotate, -y_rotate)  %>%\n  mutate(H = (atan2(y, x) * 180/pi) %% 360,\n         C = sqrt(x^2 + y^2)) %>%\n  mutate(color_value = \"white\")\nggplot(data = H_C_plane,\n       aes(H, C, color = color_value, fill = color_value)) +\n  geom_point() +\n  scale_color_identity() +\n  scale_fill_identity() +\n  scale_x_continuous(breaks = seq(45, 360, 45),\n                     minor_breaks = seq(0, 315, 45) + 45/2,\n                     labels = c('45', '90', '135', '180', \n                                '225', '270', '315', '0|360')) +\n  scale_y_continuous(limits = c(0, 180)) +\n  geom_path(data = C_circle) +\n  geom_segment(x = H_point,\n               y = 0,\n               xend = H_point,\n               yend = C_point,\n               col = \"white\") +\n  geom_point(data = C_tangent_plane, col = \"black\") +\n  geom_point(x = H_point,\n             y = C_point,\n             color = 'black',\n             fill = color_hex,\n             shape = 21) +\n  coord_polar(start = 270 * pi / 180,\n              direction = -1)\n\nget_C_tangent_plane <- function(H_point, C_point) {\n  expand_grid(x = C_point, # Plane perpendicular to H at C\n              perpendicular_from_C_L = seq(-180, 180, .5),\n              L = seq(1, 100, .5)) %>%\n    mutate(x_rotate = x * cos(H_point * pi/180) -  # rotate\n             perpendicular_from_C_L * sin(H_point * pi/180),\n           y_rotate = x * sin(H_point * pi/180) + \n             perpendicular_from_C_L * cos(H_point * pi/180)) %>%\n    mutate(x = x_rotate,\n           y = y_rotate) %>%\n    select(-x_rotate, -y_rotate)  %>%\n    mutate(H = (atan2(y, x) * 180/pi) %% 360,\n           C = sqrt(x^2 + y^2)) %>%\n    mutate(color_value = hcl(H, C, L, fixup = FALSE)) %>%\n    filter(!is.na(color_value))\n}\nC_tangent_plane <- get_C_tangent_plane(H_point, C_point)\n\ngraph_C_tangent_plane <- function(C_tangent_plane, color_hex) {\n  ggplot() +\n    geom_point(data = C_tangent_plane,\n               aes(perpendicular_from_C_L, L, \n                   color = color_value, fill = color_value)) +\n    scale_color_identity() +\n    scale_fill_identity() +\n    scale_x_reverse(\"Distance Perpendicular to C-L Plane\",\n                    labels = abs) +\n    geom_point(aes(x = 0,\n                   y = L_point),\n               color = 'black',\n               fill = color_hex,\n               shape = 21,\n               size = 2) +\n    coord_equal()\n}\ngraph_C_tangent_plane(C_tangent_plane, color_hex)\n```\n:::\n\n\nLet's first look at all our graphs for our base color. This time I'm picking pink. Next, we can see the C-L Plane, H-C Plane, and H-L Curve images to understand the color in the HCL color space.\n\n::: {style=\"display: grid; grid-template-columns: 1fr 1fr; align-items: center; justify-items: center; grid-column-gap: 1px;\"}\n<div>\n\n![Base Color: C-L Plane](c_l_plane.jpeg)\n\n</div>\n\n<div>\n\n![Base Color: H-C Plane](h_c_plane.jpeg)\n\n</div>\n:::\n\n![Base Color: H-L Curve](h_l_curve.jpeg)\n\nThen we can look at the plane tangent to the H-L Curve to see the space perpendicular to the C-L plane.\n\n::: {style=\"display: grid; grid-template-columns: 1fr 1fr; align-items: center; justify-items: center; grid-column-gap: 1px;\"}\n<div>\n\n![C Tangent Plane setup](c_tangent_plane_setup.jpeg)\n\n</div>\n\n<div>\n\n![Base Color: Plane Perpendicular to C-L Plane](c_tangent_plane.jpeg)\n\n</div>\n:::\n\nAfter the base color is understood, we can see what happens if you extend out to a sphere.\n\n<br>\n<hr>\n<center><h2>xyL Perimeter</h2></center>\n<hr>\n\nWe'll only pull points on the perimeter for this code, unlike the previous post that had points randomly throughout the sphere. We'll move away from the base point using the Cartesian coordinates of x, y, and L for the first main section. This is exactly what we did in the last post, so it should look familiar. The main new addition is cutting the shape into pieces and graphing them on facets.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"[xyL Perimeter Code]\"}\n##------------------\n# x, y, L perimeter\n##------------------\nwidth <- 15\nn_color <- 50 ^ 2\n\n# http://extremelearning.com.au/how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice/#more-3069\nget_xyl_data <- function(H_point, C_point, L_point, width, n_color) {\n  data.frame(theta = 2 * pi * seq(0, n_color - 1) / ((1 + sqrt(5)) / 2),\n             phi = acos(1 - 2 * (seq(0, n_color - 1) + .5) / n_color)) %>%\n    mutate(x = cos(theta) * sin(phi),\n           y = sin(theta) * sin(phi),\n           L = cos(phi)) %>%\n    mutate(x = x * width + C_point * cos(H_point * pi/180),\n           y = y * width + C_point * sin(H_point * pi/180),\n           L = L * width + L_point) %>%\n    mutate(H = (atan2(y, x) * 180/pi) %% 360,\n           C = sqrt(x^2 + y^2)) %>%\n    filter(L >= 0 & L <= 100 & C >= 0) %>%\n    mutate(color_value = hcl(h = H,\n                             c = C,\n                             l = L)) %>%\n    mutate(x = C * cos(H * pi/180),\n           y = C * sin(H * pi/180)) %>%\n    mutate(perpendicular_from_C_L = x * sin(-H_point * pi/180) + \n             y * cos(-H_point * pi/180),\n           parallel_along_C_L = x * cos(-H_point * pi/180) - \n             y * sin(-H_point * pi/180)) %>%\n    mutate(row_value = sample(row_number(), n()),\n           col_value = ceiling(row_value / sqrt(n_color))) %>%\n    mutate(row_value = (row_value %% sqrt(n_color)) + 1) %>%\n    mutate(L_cut = as.character(\n      cut(L, breaks = c(-Inf, seq(L_point - width, \n                                  L_point + width, \n                                  length.out = 7), \n                        Inf),\n          labels = c(L_point - width, \n                     seq(L_point - (width * .8), \n                         L_point + (width * .8), \n                         length.out = 6), \n                     L_point + width))),\n      C_cut = as.character(\n        cut(C,\n            breaks = c(-Inf, \n                       seq(C_point - width, \n                           C_point + width, \n                           length.out = 7), \n                       Inf),\n            labels = c(C_point - width, \n                       seq(C_point - (width * .8), \n                           C_point + (width * .8), \n                           length.out = 6), \n                       C_point + width))),\n      H_cut = as.character(\n        cut((180 - abs(abs(H - H_point) - 180)) * \n              sign(180 - abs(H - H_point)) * \n              sign(H - H_point),\n            breaks = c(-Inf, \n                       seq(0 - width, \n                           0 + width, \n                           length.out = 7), \n                       Inf),\n            labels = c(H_point - width, \n                       seq(H_point - (width * .8), \n                           H_point + (width * .8), \n                           length.out = 6), \n                       H_point + width) %% 360)),\n      perpendicular_from_C_L_cut = as.character(\n        cut(perpendicular_from_C_L,\n            breaks = c(-Inf, seq(0 - width, \n                                 0 + width, \n                                 length.out = 7), \n                       Inf),\n            labels = c(0 - width, \n                       seq(0 - (width * .8), \n                           0 + (width * .8), \n                           length.out = 6), \n                       0 + width))),\n      parallel_along_C_L_cut = as.character(\n        cut(parallel_along_C_L,\n            breaks = c(-Inf, \n                       seq(C_point - width, \n                           C_point + width, \n                           length.out = 7), \n                       Inf),\n            labels = c(C_point - width, \n                       seq(C_point - (width * .8), \n                           C_point + (width * .8), \n                           length.out = 6), \n                       C_point + width)))) %>%\n    mutate(L_cut = as.factor(as.numeric(L_cut)),\n           C_cut = as.factor(as.numeric(C_cut)),\n           H_cut = as.factor(as.numeric(H_cut)),\n           perpendicular_from_C_L_cut = \n             as.factor(as.numeric(perpendicular_from_C_L_cut)),\n           parallel_along_C_L_cut = \n             as.factor(as.numeric(parallel_along_C_L_cut))) %>%\n    mutate(H_cut = fct_expand(H_cut, \n                              as.character(c(H_point - width, \n                                             seq(H_point - (width * .8), \n                                                 H_point + (width * .8), \n                                                 length.out = 6), \n                                             H_point + width) %% 360)),\n           perpendicular_from_C_L_cut = \n             fct_expand(perpendicular_from_C_L_cut,\n                        as.character(c(0 - width, \n                                       seq(0 - (width * .8), \n                                           0 + (width * .8), \n                                           length.out = 6), \n                                       0 + width)))) %>%\n    mutate(H_cut = fct_relevel(H_cut, \n                               as.character(c(H_point - width, \n                                              seq(H_point - (width * .8), \n                                                  H_point + (width * .8), \n                                                  length.out = 6), \n                                              H_point + width) %% 360)),\n           perpendicular_from_C_L_cut = \n             fct_relevel(perpendicular_from_C_L_cut,\n                         as.character(c(0 - width, \n                                        seq(0 - (width * .8), \n                                            0 + (width * .8), \n                                            length.out = 6), \n                                        0 + width)))) %>%\n    mutate(H_cut = fct_rev(H_cut),\n           perpendicular_from_C_L_cut = fct_rev(perpendicular_from_C_L_cut))\n}\n\nxyl <- get_xyl_data(H_point, C_point, L_point, width, n_color)\n\ngraph_info <- function(H_point, C_point, L_point) {\n  color_hex <- hcl(H_point, \n                   C_point,\n                   L_point,\n                   fixup = FALSE)\n  \n  ggplot() +\n    geom_rect(aes(xmin = 0, xmax = 1,\n                  ymin = 0, ymax = .5), col = color_hex, fill = color_hex) +\n    geom_text(data = data.frame(x = 0,\n                                y = seq(1.5, .75, -.25),\n                                label = c(paste(\"HEX Value:\", color_hex), \n                                          paste(\"H Value:\", H_point),\n                                          paste(\"C Value:\", C_point),\n                                          paste(\"L Value:\", L_point))),\n              aes(x, y, label = label), hjust = 0, size = 4) +\n    coord_equal() +\n    theme_void()\n}\n\ngraph_sample <- function(color_points) {\n  ggplot(data = color_points,\n         aes(x = row_value,\n             y = col_value,\n             fill = color_value)) +\n    geom_tile() +\n    coord_equal() +\n    scale_fill_identity() +\n    theme_void()\n}\n\np1 <- graph_info(H_point, C_point, L_point)\np2 <- graph_sample(xyl)\np1 + p2\n\n# C L plane by H\ngraph_C_L_by_H <- function(color_points) {\n  ggplot(data = color_points, aes(C, L, \n                                  col = color_value, fill = color_value)) +\n    geom_point() +\n    scale_color_identity() +\n    scale_fill_identity() +\n    facet_wrap(~ H_cut, nrow = 2) +\n    coord_equal() \n}\n\nget_C_L_plane_by_H <- function(color_points, H_point, width) {\n  map_dfr(as.numeric(as.character(unique(color_points$H_cut))), \n          get_C_L_plane) %>%\n    mutate(H_cut = as.factor(H)) %>%\n    mutate(H_cut = fct_expand(H_cut, \n                              as.character(c(H_point - width, \n                                             seq(H_point - (width * .8), \n                                                 H_point + (width * .8), \n                                                 length.out = 6), \n                                             H_point + width) %% 360))) %>%\n    mutate(H_cut = fct_relevel(H_cut, \n                               as.character(c(H_point - width, \n                                              seq(H_point - (width * .8), \n                                                  H_point + (width * .8), \n                                                  length.out = 6), \n                                              H_point + width) %% 360))) %>%\n    mutate(H_cut = fct_rev(H_cut))\n}\nC_L_plane_by_H <- get_C_L_plane_by_H(xyl, H_point, width)\n\ngraph_C_L_plane_by_H <- function(C_L_plane, color_points) {\n  ggplot() +\n    geom_point(data = C_L_plane,\n               aes(C, L, color = color_value, fill = color_value)) +\n    geom_point(data = color_points,\n               aes(C, L, color = \"white\", fill = \"white\")) +\n    scale_x_continuous(labels = abs) +\n    scale_color_identity() +\n    scale_fill_identity() +\n    facet_wrap(~ H_cut, nrow = 2) +\n    coord_equal()\n}\ngraph_C_L_plane_by_H(C_L_plane_by_H, xyl)\ngraph_C_L_by_H(xyl)\n\n# H L curve\ngraph_H_L_by_C <- function(color_points, H_point) {\n  ggplot(data = color_points, aes((H + (180 - H_point)) %% 360, L, \n                                  color = color_value, fill = color_value)) +\n    geom_point() +\n    scale_color_identity() +\n    scale_fill_identity() +\n    scale_x_reverse('H', # Like you're standing on the inside\n                    labels = label_H_center(H_point = H_point)) +\n    facet_wrap(~ C_cut, nrow = 2) +\n    coord_equal()\n}\n\nget_H_L_curve_by_C <- function(color_points) {\n  map_dfr(as.numeric(as.character(\n    unique(color_points$C_cut))), get_H_L_curve) %>%\n    mutate(C_cut = as.factor(C))\n}\nH_L_curve_by_C <- get_H_L_curve_by_C(xyl)\n\ngraph_H_L_curve_by_C <- function(H_L_curve_by_C, color_points, H_point) {\n  ggplot() +\n    geom_point(data = H_L_curve_by_C,\n               aes((H + (180 - H_point)) %% 360, L, \n                   color = color_value, fill = color_value)) +\n    geom_point(data = color_points,\n               aes((H + (180 - H_point)) %% 360, L, \n                   color = \"white\", fill = \"white\")) +\n    scale_color_identity() +\n    scale_fill_identity() +\n    scale_x_reverse('H', # Like you're standing on the inside\n                    labels = label_H_center(H_point = H_point),\n                    limits = c(360, 0)) +\n    facet_wrap(~ C_cut, nrow = 2) +\n    coord_equal()\n}\ngraph_H_L_curve_by_C(H_L_curve_by_C, xyl, H_point)\ngraph_H_L_by_C(xyl, H_point)\n\n# H C plane by L\ngraph_x_y_by_L <- function(color_points, H_point) {\n  ggplot(data = color_points, aes(x, y, \n                                  col = color_value, fill = color_value)) +\n    geom_abline(slope = c(tan(-67.5 * pi/180), \n                          tan(-45 * pi/180), \n                          tan(-22.5 * pi/180),\n                          0, 100000,\n                          tan(22.5 * pi/180), \n                          tan(45 * pi/180), \n                          tan(67.5 * pi/180)), \n                intercept = 0,\n                color = \"white\") +\n    geom_abline(slope = tan(H_point * pi/180), \n                intercept = 0,\n                color = \"black\") +\n    geom_point() +\n    scale_color_identity() +\n    scale_fill_identity() +\n    facet_wrap(~ L_cut, nrow = 2) +\n    coord_equal() +\n    theme(axis.line=element_blank(), axis.text.x=element_blank(),\n          axis.text.y=element_blank(), axis.ticks=element_blank(),\n          axis.title.x=element_blank(), axis.title.y=element_blank(),\n          panel.grid.major=element_blank(), panel.grid.minor=element_blank())\n}\n\nget_H_C_plane_by_L <- function(color_points) {\n  map_dfr(as.numeric(\n    as.character(unique(color_points$L_cut))), get_H_C_plane) %>%\n    mutate(L_cut = as.factor(L))\n}\nH_C_plane_by_L <- get_H_C_plane_by_L(xyl)\n\ngraph_H_C_plane_by_L <- function(H_C_plane_by_L, color_points) {\n  ggplot() +\n    geom_point(data = H_C_plane_by_L,\n               aes(H, C, color = color_value, fill = color_value)) +\n    geom_point(data = color_points,\n               aes(H , C, color = \"white\", fill = \"white\")) +\n    scale_color_identity() +\n    scale_fill_identity() +\n    scale_x_continuous(breaks = seq(45, 360, 45),\n                       minor_breaks = seq(0, 315, 45) + 45/2,\n                       labels = c('45', '90', '135', '180', \n                                  '225', '270', '315', '0|360')) +\n    scale_y_continuous(limits = c(0, 180)) +\n    facet_wrap(~ L_cut, nrow = 2) +\n    coord_polar(start = 270 * pi / 180,\n                direction = -1)\n}\ngraph_H_C_plane_by_L(H_C_plane_by_L, xyl)\ngraph_x_y_by_L(xyl, H_point)\n\n# C tangent plane\nlabel_perpendicular_from_C_L_cut<- function(x) {\n  as.character(abs(as.numeric(x)))\n}\n\ngraph_parallel_perpendicular_by_L <- function(color_points) {\n  ggplot(data = color_points, \n         aes(x = parallel_along_C_L,\n             y = perpendicular_from_C_L,\n             color = color_value)) +\n    geom_point() +\n    scale_color_identity() +\n    scale_y_continuous(\"Distance Perpendicular to C-L Plane\", # similar to H\n                       labels = abs) +\n    labs(x = \"Distance Parallel to C-L Plane\") + # similar to C\n    facet_wrap(~ L_cut, nrow = 2) +\n    coord_equal()\n}\ngraph_parallel_perpendicular_by_L(xyl)\n\ngraph_perpendicular_L_by_parallel <- function(color_points) {\n  ggplot(data = color_points, \n         aes(x = perpendicular_from_C_L,\n             y = L,\n             color = color_value)) +\n    geom_point() +\n    scale_color_identity() +\n    scale_x_continuous(\"Distance Perpendicular to C-L Plane\",\n                       labels = abs) +\n    scale_y_continuous(labels = abs) +\n    facet_wrap(~ parallel_along_C_L_cut, nrow = 2) +\n    coord_equal()\n}\ngraph_perpendicular_L_by_parallel(xyl)\n\ngraph_parallel_L_by_perpendicular <- function(color_points) {\n  ggplot(data = color_points, \n         aes(x = parallel_along_C_L,\n             y = L,\n             color = color_value)) +\n    geom_point() +\n    scale_color_identity() +\n    labs(x = \"Distance Parallel to C-L Plane\") +\n    facet_wrap(~ perpendicular_from_C_L_cut, nrow = 2,\n               labeller = as_labeller(label_perpendicular_from_C_L_cut)) +\n    coord_equal()\n}\ngraph_parallel_L_by_perpendicular(xyl)\n```\n:::\n\n\n![xyL: Info](xyl_info.jpeg)\n\nAbove, we see the basic information about the base color and the points sampled around the sphere's perimeter (width is 15 units). Below, we see the sphere cut up by C-L Planes at different Hue values. We see that as we move across different values for our Hue, we slice through the sphere to get different shapes. For example, on the right image, the ends are moved left slightly, and the doughnuts in the middle values tend to have a little more width on the right side. The distortion occurs because our cuts are fanning across the sphere at an angle, not moving along in a straight line. So, one side gets a little more of the perimeter to plot.\n\n::: {layout-ncol=\"2\"}\n![xyL: C-L Plane by H cuts](xyl_c_l_plane.jpeg)\n\n![xyL: C-L by H cuts](xyl_c_l.jpeg)\n:::\n\nThe next set shows the H-L Curve by different Chroma values. Here, we might expect to see circles, but instead, we get ovals. These shapes occur because the ring made by moving Hue through the sphere cuts along a curve, then it's flattened for these facets. Also, technically the facets are a little off because the width of the graph should be increasing as Chroma increases. So even though they show the same Hue values, the arc length of the circle should be getting longer. Therefore the graphs should be getting wider.\n\n::: {layout-ncol=\"2\"}\n![xyL: H-L Curve by C cuts](xyl_h_l_curve.jpeg)\n\n![xyL: H-L by C cuts](xyl_h_l.jpeg)\n:::\n\nIn the next set, we finally get our nice circles. As we slice through our sphere for different Luminance values, we get our circles in the H-C Planes.\n\n::: {layout-ncol=\"2\"}\n![xyL: H-C Plane by L cuts](xyl_h_c_plane.jpeg)\n\n![xyL: H-C by L cuts](xyl_h_c.jpeg)\n:::\n\nThe following three images also have circles because we're cutting our sphere along straight lines equal distances from each other. The first facet set looks at the sphere from up above as we cut through different Luminance values. This image is the same as the right side in the previous group, but each sub-image gets rotated, so the Hue angle moves flat left to right. The x-axis is the distance along the C-L Plane that cuts the sphere in half. This distance isn't equivalent to Chroma because that moves at an angle determined by Hue, but it is related. The values are the Chroma values on the C-L Plane shifted in a straight line from the C-L Plane. The y-axis is the distance from the C-L Plane in either direction.\n\n![xyL: Parallel-Perpendicular Distances by L cuts](xyl_par_per.jpeg)\n\nThe next two images both have the Luminance values along the y-axis but cut the sphere differently. The left side slices the sphere moving out from the center of the HCL color space along the Chroma values. Here we see the nice circles instead of ovals for the images of the H-L cut by C. The right side cuts are made parallel to the C-L Plane and move along a straight line. We're also getting circles that aren't a little lop-sided, unlike the C-L cut by H ones.\n\n::: {layout-ncol=\"2\"}\n![xyL: Perpendicular Distance-L by Parallel Distance cuts](xyl_per_l.jpeg)\n\n![xyL: Parallel Distance-L by Perpendicular Distance cuts](xyl_par_l.jpeg)\n:::\n\n<br>\n<hr>\n<center><h2>HCL Perimeter</h2></center>\n<hr>\n\nWe'll move away from the base color along Hue, Chroma, and Luminance for the second main section. So we'll curve around when changing Hue values.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"[HCL Perimeter Code]\"}\n##------------------\n# H, C, L, perimeter\n##------------------\nget_hcl_data <- function(H_point, C_point, L_point, width, n_color) {\n data.frame(theta = 2 * pi * seq(0, n_color - 1) / ((1 + sqrt(5)) / 2),\n                  phi = acos(1 - 2 * (seq(0, n_color - 1) + .5) / n_color)) %>%\n  mutate(H = cos(theta) * sin(phi),\n         C = sin(theta) * sin(phi),\n         L = cos(phi)) %>%\n  mutate(H = H * width + H_point,\n         C = C * width + C_point,\n         L = L * width + L_point) %>%\n  mutate(H = H %% 360) %>% # not really needed except for graphs\n  filter(L >= 0 & L <= 100 & C >= 0) %>%\n  mutate(color_value = hcl(h = H,\n                           c = C,\n                           l = L)) %>%\n  mutate(x = C * cos(H * pi/180),\n         y = C * sin(H * pi/180)) %>%\n  mutate(perpendicular_from_C_L = x * sin(-H_point * pi/180) + \n           y * cos(-H_point * pi/180), # not a C value since we didn't rotate by H\n         parallel_along_C_L = x * cos(-H_point * pi/180) - \n           y * sin(-H_point * pi/180)) %>%\n  mutate(row_value = sample(row_number(), n()),\n         col_value = ceiling(row_value / sqrt(n_color))) %>%\n  mutate(row_value = (row_value %% sqrt(n_color)) + 1) %>%\n  mutate(L_cut = as.character(\n    cut(L, breaks = c(-Inf, seq(L_point - width, \n                                L_point + width, \n                                length.out = 7), \n                      Inf),\n        labels = c(L_point - width, \n                   seq(L_point - (width * .8), \n                       L_point + (width * .8), \n                       length.out = 6), \n                   L_point + width))),\n         C_cut = as.character(\n           cut(C,\n               breaks = c(-Inf, \n                          seq(C_point - width, \n                              C_point + width, \n                              length.out = 7), \n                          Inf),\n               labels = c(C_point - width, \n                          seq(C_point - (width * .8), \n                              C_point + (width * .8), \n                              length.out = 6), \n                          C_point + width))),\n         H_cut = as.character(\n           cut((180 - abs(abs(H - H_point) - 180)) * \n                 sign(180 - abs(H - H_point)) * \n                 sign(H - H_point),\n               breaks = c(-Inf, \n                          seq(0 - width, \n                              0 + width, \n                              length.out = 7), \n                          Inf),\n               labels = c(H_point - width, \n                          seq(H_point - (width * .8), \n                              H_point + (width * .8), \n                              length.out = 6), \n                          H_point + width) %% 360)),\n         perpendicular_from_C_L_cut = as.character(\n           cut(perpendicular_from_C_L,\n               breaks = c(-Inf, seq(0 - width, \n                                    0 + width, \n                                    length.out = 7), \n                          Inf),\n               labels = c(0 - width, \n                          seq(0 - (width * .8), \n                              0 + (width * .8), \n                              length.out = 6), \n                          0 + width))),\n         parallel_along_C_L_cut = as.character(\n           cut(parallel_along_C_L,\n               breaks = c(-Inf, \n                          seq(C_point - width, \n                              C_point + width, \n                              length.out = 7), \n                          Inf),\n               labels = c(C_point - width, \n                          seq(C_point - (width * .8), \n                              C_point + (width * .8), \n                              length.out = 6), \n                          C_point + width)))) %>%\n  mutate(L_cut = as.factor(as.numeric(L_cut)),\n         C_cut = as.factor(as.numeric(C_cut)),\n         H_cut = as.factor(as.numeric(H_cut)),\n         perpendicular_from_C_L_cut = \n           as.factor(as.numeric(perpendicular_from_C_L_cut)),\n         parallel_along_C_L_cut = \n           as.factor(as.numeric(parallel_along_C_L_cut))) %>%\n  mutate(H_cut = fct_expand(H_cut, \n                            as.character(c(H_point - width, \n                                           seq(H_point - (width * .8), \n                                               H_point + (width * .8), \n                                               length.out = 6), \n                                           H_point + width) %% 360)),\n         perpendicular_from_C_L_cut = \n           fct_expand(perpendicular_from_C_L_cut,\n                      as.character(c(0 - width, \n                                     seq(0 - (width * .8), \n                                         0 + (width * .8), \n                                         length.out = 6), \n                                     0 + width)))) %>%\n  mutate(H_cut = fct_relevel(H_cut, \n                             as.character(c(H_point - width, \n                                            seq(H_point - (width * .8), \n                                                H_point + (width * .8), \n                                                length.out = 6), \n                                            H_point + width) %% 360)),\n         perpendicular_from_C_L_cut = \n           fct_relevel(perpendicular_from_C_L_cut,\n                      as.character(c(0 - width, \n                                     seq(0 - (width * .8), \n                                         0 + (width * .8), \n                                         length.out = 6), \n                                     0 + width)))) %>%\n  mutate(H_cut = fct_rev(H_cut),\n         perpendicular_from_C_L_cut = fct_rev(perpendicular_from_C_L_cut))\n}\n\nhcl <- get_hcl_data(H_point, C_point, L_point, width, n_color)\n\np1 <- graph_info(H_point, C_point, L_point)\np2 <- graph_sample(hcl)\np1 + p2\n\n# C L plane by H\nC_L_plane_by_H <- get_C_L_plane_by_H(hcl, H_point, width)\ngraph_C_L_by_H(hcl)\ngraph_C_L_plane_by_H(C_L_plane_by_H, hcl)\n\n# H L curve\nH_L_curve_by_C <- get_H_L_curve_by_C(hcl)\ngraph_H_L_by_C(hcl, H_point)\ngraph_H_L_curve_by_C(H_L_curve_by_C, hcl, H_point)\n\n# H C plane by L\nH_C_plane_by_L <- get_H_C_plane_by_L(hcl)\ngraph_x_y_by_L(hcl, H_point)\ngraph_H_C_plane_by_L(H_C_plane_by_L, hcl)\n\n# C tangent plane\ngraph_parallel_perpendicular_by_L(hcl)\n\ngraph_perpendicular_L_by_parallel(hcl)\n\ngraph_parallel_L_by_perpendicular(hcl)\n```\n:::\n\n\n![HCL: Info](hcl_info.jpeg)\n\nThis first set of graphs plots the C-L plane split by Hue values with both the perimeter and where it fits in the color space. We see these nice circles as the perimeter is cut moving along Hue values.\n\n::: {layout-ncol=\"2\"}\n![HCL: C-L Plane by H cuts](hcl_c_l_plane.jpeg)\n\n![HCL: C-L by H cuts](hcl_c_l.jpeg)\n:::\n\nThe next set shows H-L Curve split by different Chroma values. We're also getting nice circles, unlike the xyL section.\n\n::: {layout-ncol=\"2\"}\n![HCL: H-L Curve by C cuts](hcl_h_l_curve.jpeg)\n\n![HCL: H-L by C cuts](hcl_h_l.jpeg)\n:::\n\nThe following graph breaks the trend of nice circles. Here we see teardrop shapes instead. The next few images pull this apart a little more.\n\n::: {layout-ncol=\"2\"}\n![HCL: H-C Plane by L cuts](hcl_h_c_plane.jpeg)\n\n![HCL: H-C by L cuts](hcl_h_c.jpeg)\n:::\n\nHere we see the teardrop shapes in more detail. Because we created our \"sphere\" following polar coordinates, it doesn't turn out as we might expect. This shape's height is a function of what a sphere should be but augmented by the distance between Hue values increasing when Chroma increases. Notice that the center Chroma value is at 26. Not in the middle of the circular part, like at 30-ish.\n\n![HCL: Parallel-Perpendicular Distances by L cuts](hcl_par_per.jpeg)\n\nWe also get a squished version for the image on the left. There are fewer cuts because the shape doesn't reach out as far as the image on the right.\n\n::: {layout-ncol=\"2\"}\n![HCL: Perpendicular Distance-L by Parallel Distance cuts](hcl_per_l.jpeg)\n\n![HCL: Parallel Distance-L by Perpendicular Distance cuts](hcl_par_l.jpeg)\n:::\n\nIt is a little unwieldy to compare the different main sections apart, so we'll add them together in the next one.\n\n<br>\n<hr>\n<center><h2>Compare Perimeters</h2></center>\n<hr>\n\nFor the following images, the two sets we previously created are stuck together and then graphed to highlight the differences well.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"[Compare Code]\"}\n##-------\n# Compare\n##-------\ncompare <- rbind(xyl[, c('H', 'C', 'L', 'x', 'y', \n                         'H_cut', 'C_cut', 'L_cut', \n                         'perpendicular_from_C_L', 'parallel_along_C_L', \n                         'perpendicular_from_C_L_cut', 'parallel_along_C_L_cut',\n                         'row_value', 'col_value', 'color_value')],\n                 hcl[, c('H', 'C', 'L', 'x', 'y', \n                         'H_cut', 'C_cut', 'L_cut', \n                         'perpendicular_from_C_L', 'parallel_along_C_L', \n                         'perpendicular_from_C_L_cut', 'parallel_along_C_L_cut',\n                         'row_value', 'col_value', 'color_value')]) %>%\n  mutate(setting = c(rep('XYL', n_color), rep('HCL', n_color))) \n\n# C L plane\ngraph_C_L_by_H_comparison <- function(color_points) {\n  ggplot(data = color_points, aes(C, L, col = setting)) +\n    geom_point(alpha = .5) +\n    facet_wrap(~ H_cut, nrow = 2) +\n    coord_equal() +\n    scale_color_discrete(\"\") +\n    theme(legend.position = \"bottom\")\n}\ngraph_C_L_by_H_comparison(compare)\n\n# H L curve\ngraph_H_L_by_C_comparison <- function(color_points, H_point) {\n  ggplot(data = color_points, \n         aes((H + (180 - H_point)) %% 360, L, color = setting)) +\n    geom_point(alpha = .5) +\n    scale_x_reverse('H',\n                    labels = label_H_center(H_point = H_point)) +\n    facet_wrap(~ C_cut, nrow = 2) +\n    coord_equal() +\n    scale_color_discrete(\"\") +\n    theme(legend.position = \"bottom\")\n}\ngraph_H_L_by_C_comparison(compare, H_point)\n\n# H C plane\ngraph_x_y_by_L_comparison <- function(color_points, H_point) {\n  ggplot(data = color_points, aes(x, y, col = setting)) +\n    geom_abline(slope = c(tan(-67.5 * pi/180), \n                          tan(-45 * pi/180), \n                          tan(-22.5 * pi/180),\n                          0, 100000,\n                          tan(22.5 * pi/180), \n                          tan(45 * pi/180), \n                          tan(67.5 * pi/180)), \n                intercept = 0,\n                color = \"white\") +\n    geom_abline(slope = tan(H_point * pi/180), \n                intercept = 0,\n                color = \"black\") +\n    geom_point(alpha = .5) +\n    facet_wrap(~ L_cut, nrow = 2) +\n    coord_equal() +\n    scale_color_discrete(\"\") +\n    theme(legend.position = \"bottom\",\n          axis.line=element_blank(), axis.text.x=element_blank(),\n          axis.text.y=element_blank(), axis.ticks=element_blank(),\n          axis.title.x=element_blank(), axis.title.y=element_blank(),\n          panel.grid.major=element_blank(), panel.grid.minor=element_blank())\n}\ngraph_x_y_by_L_comparison(compare, H_point)\n\n# C tangent plane\ngraph_parallel_perpendicular_by_L_comparison <- function(color_points) {\n  ggplot(data = color_points, \n         aes(x = parallel_along_C_L,\n             y = perpendicular_from_C_L,\n             color = setting)) +\n    geom_point(alpha = .5) +\n    scale_y_continuous(\"Distance Perpendicular to C-L Plane\",\n                       labels = abs) +\n    labs(x = \"Distance Parallel to C-L Plane\") +\n    facet_wrap(~ L_cut, nrow = 2) +\n    coord_equal() +\n    scale_color_discrete(\"\") +\n    theme(legend.position = \"bottom\")\n}\ngraph_parallel_perpendicular_by_L_comparison(compare)\n\ngraph_perpendicular_L_by_parallel_comparison <- function(color_points) {\n  ggplot(data = color_points, \n         aes(x = perpendicular_from_C_L,\n             y = L,\n             color = setting)) +\n    geom_point(alpha = .5) +\n    scale_x_continuous(\"Distance Perpendicular to C-L Plane\", \n            labels = abs) +\n    scale_y_continuous(labels = abs) +\n    facet_wrap(~ parallel_along_C_L_cut, nrow = 2) +\n    coord_equal() +\n    scale_color_discrete(\"\") +\n    theme(legend.position = \"bottom\")\n}\ngraph_perpendicular_L_by_parallel_comparison(compare)\n\ngraph_parallel_L_by_perpendicular_comparison <- function(color_points) {\n  ggplot(data = color_points, \n         aes(x = parallel_along_C_L,\n             y = L,\n             color = setting)) +\n    geom_point(alpha = .5) +\n    labs(x = \"Distance Parallel to C-L Plane\") +\n    facet_wrap(~ perpendicular_from_C_L_cut, nrow = 2,\n               labeller = as_labeller(label_perpendicular_from_C_L_cut)) +\n    coord_equal() +\n    scale_color_discrete(\"\") +\n    theme(legend.position = \"bottom\")\n}\ngraph_parallel_L_by_perpendicular_comparison(compare)\n\ncompare <- compare %>%\n  group_by(setting) %>%\n  arrange((180 - abs(abs(H - H_point) - 180)) * \n            sign(180 - abs(H - H_point)) * sign(H - H_point)) %>%\n  mutate(col_value = ceiling(row_number() / sqrt(n_color))) %>%\n  arrange(col_value, L) %>%\n  group_by(setting, col_value) %>%\n  mutate(row_value = row_number())\n\nggplot(data = compare,\n       aes(x = col_value,\n           y = row_value,\n           fill = color_value)) +\n  geom_tile() +\n  coord_equal() +\n  scale_fill_identity() +\n  theme_void() +\n  facet_grid(~setting)\n\ncompare <- compare %>%\n  group_by(setting) %>%\n  arrange((180 - abs(abs(H - H_point) - 180)) * \n            sign(180 - abs(H - H_point)) * sign(H - H_point)) %>%\n  mutate(col_value = ceiling(row_number() / sqrt(n_color))) %>%\n  arrange(col_value, C) %>%\n  group_by(setting, col_value) %>%\n  mutate(row_value = row_number())\n\nggplot(data = compare,\n       aes(x = col_value,\n           y = row_value,\n           fill = color_value)) +\n  geom_tile() +\n  coord_equal() +\n  scale_fill_identity() +\n  theme_void() +\n  facet_grid(~setting)\n```\n:::\n\n\nThis section will have graphs with points from the xyL function in blue and HCL in orange. In the left image, we see the lop-sidedness of the xyL points with the circles of the HCL ones. Also, we can easily see that the XYL points stretch out to farther Hue values. Then we have the ovals for xyL and circles for HCL.\n\n::: {layout-ncol=\"2\"}\n![Comparison: C-L by L cuts](compare_c_l.jpeg)\n\n![Comparison: H-L by C cuts](compare_h_l.jpeg)\n:::\n\nThen we can see the circles for xyL and teardrops for HCL.\n\n::: {layout-ncol=\"2\"}\n![Comparison: H-C by L cuts](compare_h_c.jpeg)\n\n![Comparison: Parallel-Perpendicular by L cuts](compare_par_per.jpeg)\n:::\n\nFinally, we get a comparison that confirms the HCL function results in squeezing the perimeter, not stretching it vertically.\n\n::: {layout-ncol=\"2\"}\n![Comparison: Perpendicular-L by Parallel cuts](compare_per_l.jpeg)\n\n![Comparison: Parallel-L by Perpendicular cuts](compare_par_l.jpeg)\n:::\n\nGraphing the perimeters is nice to see what's going on mathematically in the space, but the main result is in the end colors. So the last images of this main section show the direct colors of the samples.\n\nThe first comparison has the samples sorted by Hue for the columns, then within each column, sorted by Luminance. I can't tell a huge difference, but the Hue values for xyL seem to stretch slightly more than HCL, and HCL has a little more gray.\n\n![Comparison: Samples H by L](compare_samples.jpeg)\n\nThe second comparison has the samples sorted by Hue (like the first comparison), then sorted by Chroma. To me, this looks very different for having the same colors in the same columns. The HCL square is a little grayer at the bottom.\n\n![Comparison: Samples H by C](compare_samples2.jpeg)\n\nFor the final two main sections, we'll change only the Chroma value. First, we'll move everything closer to the center.\n\n<br>\n<hr>\n<center><h2>Lower Chroma Value</h2></center>\n<hr>\n\nWe'll start by changing the base Chroma value from 26 to 16. Everything else is the same.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"[Lower Chroma Value Code]\"}\n## Try lower value of C ----\nC_point <- 16\n\nxyl <- get_xyl_data(H_point, C_point, L_point, width, n_color)\n\nhcl <- get_hcl_data(H_point, C_point, L_point, width, n_color)\n\ncompare <- rbind(xyl[, c('H', 'C', 'L', 'x', 'y', \n                         'H_cut', 'C_cut', 'L_cut', \n                         'perpendicular_from_C_L', 'parallel_along_C_L', \n                         'perpendicular_from_C_L_cut', 'parallel_along_C_L_cut',\n                         'row_value', 'col_value', 'color_value')],\n                 hcl[, c('H', 'C', 'L', 'x', 'y', \n                         'H_cut', 'C_cut', 'L_cut', \n                         'perpendicular_from_C_L', 'parallel_along_C_L', \n                         'perpendicular_from_C_L_cut', 'parallel_along_C_L_cut',\n                         'row_value', 'col_value', 'color_value')]) %>%\n  mutate(setting = c(rep('XYL', n_color), rep('HCL', n_color))) \n\n# C L plane\ngraph_C_L_by_H_comparison(compare)\n\n# H L curve\ngraph_H_L_by_C_comparison(compare, H_point)\n\n# H C plane\ngraph_x_y_by_L_comparison(compare, H_point)\n\n# C tangent plane\ngraph_parallel_perpendicular_by_L_comparison(compare)\n\ngraph_perpendicular_L_by_parallel_comparison(compare)\n\ngraph_parallel_L_by_perpendicular_comparison(compare)\n\ncompare <- compare %>%\n  group_by(setting) %>%\n  arrange((180 - abs(abs(H - H_point) - 180)) * \n            sign(180 - abs(H - H_point)) * sign(H - H_point)) %>%\n  mutate(col_value = ceiling(row_number() / sqrt(n_color))) %>%\n  arrange(col_value, L) %>%\n  group_by(setting, col_value) %>%\n  mutate(row_value = row_number())\n\nggplot(data = compare,\n       aes(x = col_value,\n           y = row_value,\n           fill = color_value)) +\n  geom_tile() +\n  coord_equal() +\n  scale_fill_identity() +\n  theme_void() +\n  facet_grid(~setting)\n\ncompare <- compare %>%\n  group_by(setting) %>%\n  arrange((180 - abs(abs(H - H_point) - 180)) * \n            sign(180 - abs(H - H_point)) * sign(H - H_point)) %>%\n  mutate(col_value = ceiling(row_number() / sqrt(n_color))) %>%\n  arrange(col_value, C) %>%\n  group_by(setting, col_value) %>%\n  mutate(row_value = row_number())\n\nggplot(data = compare,\n       aes(x = col_value,\n           y = row_value,\n           fill = color_value)) +\n  geom_tile() +\n  coord_equal() +\n  scale_fill_identity() +\n  theme_void() +\n  facet_grid(~setting)\n```\n:::\n\n\nFrom these graphs, we can see everything is exaggerated. For example, the first two images have similar circles for HCL, but xyL is breaking apart and getting stretched.\n\n::: {layout-ncol=\"2\"}\n![Lower C: C-L by L cuts](C_lower_c_l.jpeg)\n\n![Lower C: H-L by C cuts](C_lower_h_l.jpeg)\n:::\n\nThen we see the circles for xyL, but HCL has a very tight teardrop shape.\n\n::: {layout-ncol=\"2\"}\n![Lower C: H-C by L cuts](C_lower_h_c.jpeg)\n\n![Lower C: Parallel-Perpendicular by L cuts](C_lower_par_per.jpeg)\n:::\n\nThe same trend continues with the exaggeration for HCL.\n\n::: {layout-ncol=\"2\"}\n![Lower C: Perpendicular-L by Parallel cuts](C_lower_per_l.jpeg)\n\n![Lower C: Parallel-L by Perpendicular cuts](C_lower_par_l.jpeg)\n:::\n\nFinally, we can compare the sampled colors directly.\n\n::: {layout-ncol=\"2\"}\n![Lower C: Samples H by L](C_lower_samples.jpeg)\n\n![Lower C: Samples H by C](C_lower_samples2.jpeg)\n:::\n\n<br>\n<hr>\n<center><h2>Higher Chroma Value</h2></center>\n<hr>\n\nFor the last main section, we'll set Chroma to 75.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"[Higher Chroma Value Code]\"}\n## Try higher value of C ----\nC_point <- 75\n \nxyl <- get_xyl_data(H_point, C_point, L_point, width, n_color)\n\nhcl <- get_hcl_data(H_point, C_point, L_point, width, n_color)\n\ncompare <- rbind(xyl[, c('H', 'C', 'L', 'x', 'y', \n                         'H_cut', 'C_cut', 'L_cut', \n                         'perpendicular_from_C_L', 'parallel_along_C_L', \n                         'perpendicular_from_C_L_cut', 'parallel_along_C_L_cut',\n                         'row_value', 'col_value', 'color_value')],\n                 hcl[, c('H', 'C', 'L', 'x', 'y', \n                         'H_cut', 'C_cut', 'L_cut', \n                         'perpendicular_from_C_L', 'parallel_along_C_L', \n                         'perpendicular_from_C_L_cut', 'parallel_along_C_L_cut',\n                         'row_value', 'col_value', 'color_value')]) %>%\n  mutate(setting = c(rep('XYL', n_color), rep('HCL', n_color))) \n\n# C L plane\ngraph_C_L_by_H_comparison(compare)\n\n# H L curve\ngraph_H_L_by_C_comparison(compare, H_point)\n\n# H C plane\ngraph_x_y_by_L_comparison(compare, H_point)\n\n# C tangent plane\ngraph_parallel_perpendicular_by_L_comparison(compare)\n\ngraph_perpendicular_L_by_parallel_comparison(compare)\n\ngraph_parallel_L_by_perpendicular_comparison(compare)\n\ncompare <- compare %>%\n  group_by(setting) %>%\n  arrange((180 - abs(abs(H - H_point) - 180)) * \n            sign(180 - abs(H - H_point)) * sign(H - H_point)) %>%\n  mutate(col_value = ceiling(row_number() / sqrt(n_color))) %>%\n  arrange(col_value, L) %>%\n  group_by(setting, col_value) %>%\n  mutate(row_value = row_number())\n\nggplot(data = compare,\n       aes(x = col_value,\n           y = row_value,\n           fill = color_value)) +\n  geom_tile() +\n  coord_equal() +\n  scale_fill_identity() +\n  theme_void() +\n  facet_grid(~setting)\n\ncompare <- compare %>%\n  group_by(setting) %>%\n  arrange((180 - abs(abs(H - H_point) - 180)) * \n            sign(180 - abs(H - H_point)) * sign(H - H_point)) %>%\n  mutate(col_value = ceiling(row_number() / sqrt(n_color))) %>%\n  arrange(col_value, C) %>%\n  group_by(setting, col_value) %>%\n  mutate(row_value = row_number())\n\nggplot(data = compare,\n       aes(x = col_value,\n           y = row_value,\n           fill = color_value)) +\n  geom_tile() +\n  coord_equal() +\n  scale_fill_identity() +\n  theme_void() +\n  facet_grid(~setting)\n```\n:::\n\n\nThis time, the results have a different shape. Now, HCL stretches out farther than xyL (but still in a circle).\n\n::: {layout-ncol=\"2\"}\n![Higher C: C-L by L cuts](C_higher_c_l.jpeg)\n\n![Higher C: H-L by C cuts](C_higher_h_l.jpeg)\n:::\n\nThe graphs from above show the stretching well. Instead of the teardrop shape, we now have ovals. At some point in increasing the Chroma value, the HCL function surpasses xyL.\n\n::: {layout-ncol=\"2\"}\n![Higher C: H-C by L cuts](C_higher_h_c.jpeg)\n\n![Higher C: Parallel-Perpendicular by L cuts](C_higher_par_per.jpeg)\n:::\n\nWe see the same trend continue here.\n\n::: {layout-ncol=\"2\"}\n![Higher C: Perpendicular-L by Parallel cuts](C_higher_per_l.jpeg)\n\n![Higher C: Parallel-L by Perpendicular cuts](C_higher_par_l.jpeg)\n:::\n\nAnd finally, we can compare the examples again.\n\n::: {layout-ncol=\"2\"}\n![Higher C: Samples H by L](C_higher_samples.jpeg)\n\n![Higher C: Samples H by C](C_higher_samples2.jpeg)\n:::\n\nI think at the end of the post, I'm supposed to say one is better than the other, but I think they're just different. It really depends on what you're looking for in selecting colors. Looking at the colors is the best way to do that, but the other graphs help explain what is happening and determine the next steps.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}