{
  "hash": "34d4f9a5f0f12896977e3fc03136a44f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Country Maps\"\ndescription: \"A map of each country for flash cards\"\ndate: \"2025-10-16\"\ncategories: [Python]\nimage: \"Algeria.png\"\nexecute: \n  eval: false\njupyter: python3\n---\n\n\nThis post makes a set of flashcards for countries. I chose an othrographic projection so that the location and sizes would be right.\n\n<hr>\n<center>\n<h2>Imports</h2>\n</center>\n<hr>\n\n`geopandas` is the main package for working with this geography data. It's basically a `pandas` dataframe with an additional `geometry` column for plotting. I tried doing everything with only `geopandas` and `matplotlib`, but the plots would end up with odd artifacts. Using the `cartopy` package for plotting fixed them.\n\n::: {#65681136 .cell execution_count=1}\n``` {.python .cell-code}\nimport cartopy\nimport cartopy.crs as ccrs\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import inset_locator\nimport pandas as pd\nfrom shapely.geometry import box, Point\n```\n:::\n\n\n<br>\n<hr>\n<center>\n<h2>Set up the data</h2>\n</center>\n<hr>\n\nThe data is saved from [Natural Earth](www.naturalearthdata.com). There are a lot of choices to make here. I wanted to use the [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1), but there are a few extras I added, like Kosovo. Some countries span a large area that can't be graphed well because of the size, like France with Clipperton Island. For those cases, I drop any very small locations. For naming, if it was a group, like the United Kingdom, I wanted to use the group name, `ADMIN`, else the `NAME_LONG` tended to provide better text. Lastly, all the geometries were combined together.\n\n::: {#a36d3318 .cell execution_count=2}\n``` {.python .cell-code}\n# Load the world map from geopandas's built-in dataset\n# https://www.naturalearthdata.com/downloads/110m-cultural-vectors/110m-admin-0-countries/\nworld = gpd.read_file(\"ne_10m_admin_0_map_units.zip\", encoding='utf-8')\n\n# Save all data for easier manual checking\nworld_save = pd.DataFrame(world.drop(columns='geometry'))\nworld_save.to_csv('world.csv', index=False)\n\n# Fix some missing 'ISO_A3_EH'\nworld.loc[(world['ISO_A3_EH'] == '-99') & (world['TYPE'].isin(['Disputed', 'Geo unit', 'Sovereign country'])), 'ISO_A3_EH'] = world.loc[(world['ISO_A3_EH'] == '-99') & (world['TYPE'].isin(['Disputed', 'Geo unit', 'Sovereign country'])), 'GU_A3']\nworld = world[['ADMIN', 'NAME_LONG', 'ISO_A3_EH', 'geometry']]\n\n# drop out very small dependencies, like clipperton island\nworld['area'] = world.area\nworld['area_percent'] = world['area'] / world.groupby('ISO_A3_EH')['area'].transform('sum') * 100\nworld = world.loc[world['area_percent'] >= 2.5]\n\n# use NAME_LONG for the name\n# unless there's more than one row, then use ADMIN\nworld['ISO_COUNT'] = world.groupby('ISO_A3_EH')['ISO_A3_EH'].transform('size')\nworld['NAME'] = world['NAME_LONG']\nworld.loc[world['ISO_COUNT'] > 1, 'NAME'] = world.loc[world['ISO_COUNT'] > 1, 'ADMIN']\n\n# Fix Falkland Islands / Malvinas for use as a file name\nworld['NAME'] = world['NAME'].str.replace('/', '-')\n\n# combine geometries together\nworld = world.dissolve(by='ISO_A3_EH').reset_index()\n\n# Save information for a file\ncountry_data = {}\n```\n:::\n\n\n<br>\n<hr>\n<center>\n<h2>The Main Loop Part 1</h2>\n</center>\n<hr>\n\nFor each country, I needed to find a lat/long point to set the orthographic projection. This should be the center of the country. I first use a point on the bounding box to get close and estimate the [UTM](https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system) crs from there. Averaging the points on the bounding box or using `centroid` will fail on counties like Kiribati because it cross the International Date Line. An average of the bounding box wraps back around to the Atlantic Ocean instead of the center of the country in the Pacific Ocean. Therefore the multistep process of using UTM then `centroid` has to be done, instead of using `centroid` from the start. Also, Antarctica fails for estimating the UTM crs, so it is handled separately. Then after setting that point, the centroid of the country can be found and the projections can be set from there. Finally, some stats are saved that are used for determining mapping options.\n\n::: {#48cdc7c2 .cell execution_count=3}\n``` {.python .cell-code}\nfor country_a3 in world['ISO_A3_EH']:\n    country_name = world.loc[world['ISO_A3_EH'] == country_a3]['NAME'].item()\n    print(f'{country_a3}: {country_name}')\n\n    # Skip over additional areas\n    if country_a3 == '-99':\n        continue\n\n    # Antartica fails on estimate_utm_crs()\n    if country_a3 == 'ATA':\n        # Find a starting point\n        location_data = pd.DataFrame({\n            'location': ['center'],\n            'x': 0,\n            'y': -90\n        })\n        geometry = [Point(xy) for xy in zip(location_data.x, location_data.y)]\n        location_data = gpd.GeoDataFrame(location_data,\n                                         geometry=geometry,\n                                         crs='EPSG:4326')\n\n        # Now convert to ortho based on the correct point\n        crs = ccrs.Orthographic(central_latitude=-90,\n                                central_longitude=0)\n        crs_proj4 = crs.proj4_init\n\n    else:\n        # Find a point to base everything on\n        # Kiribati shows it needs to be bounds becase it crosses over the edge\n        # so using a centeroid fails because it averages out to the Atlantic\n        # instead of the pacific\n        country = world[world['ISO_A3_EH'] == country_a3]\n        xmin, ymin, xmax, ymax = country[\"geometry\"].total_bounds\n        location_data = pd.DataFrame({\n            'location': ['center'],\n            'x': [xmin],\n            'y': [ymin]\n        })\n        geometry = [Point(xy) for xy in zip(location_data.x, location_data.y)]\n        location_data = gpd.GeoDataFrame(location_data,\n                                         geometry=geometry,\n                                         crs=country.crs)\n\n        # Convert country data to a crs that works around here\n        country = country.to_crs(location_data.estimate_utm_crs(datum_name='WGS 84'))\n\n        # Now need to convert center to usable form\n        location_data = pd.DataFrame({\n            'location': ['center'],\n            'x': [country.centroid.x],\n            'y': [country.centroid.y]\n        })\n        geometry = [Point(xy) for xy in zip(location_data.x, location_data.y)]\n        location_data = gpd.GeoDataFrame(location_data,\n                                         geometry=geometry,\n                                         crs=country.crs)\n\n        # now to lat long\n        location_data = location_data.to_crs('EPSG:4326')\n\n        # Now convert to ortho based on the correct point\n        crs = ccrs.Orthographic(central_latitude=location_data['geometry'].y.item(),\n                                central_longitude=location_data['geometry'].x.item())\n        crs_proj4 = crs.proj4_init\n\n    # Convert the world, location, and country data to the right projection\n    world_ortho = world.to_crs(crs=crs_proj4)\n    location_data = location_data.to_crs(crs=crs_proj4)\n    country = country.to_crs(crs=crs_proj4)\n\n    # Find some sizes to determine how to plot the data\n    country = world_ortho[world_ortho['ISO_A3_EH'] == country_a3]\n    xmin, ymin, xmax, ymax = country[\"geometry\"].total_bounds\n    country_size = (xmax - xmin)*(ymax - ymin)\n    country_area = country['geometry'].area.item()\n    country_proportion = country_area/country_size\n```\n:::\n\n\n<br>\n<hr>\n<center>\n<h2>The Main Loop Part 2</h2>\n</center>\n<hr>\n\nThe rest of the loop plots the maps. First, some defauls are set for each plot. Backgrounds, the world map, and the individual country are plotted. Then, if the country is very small, an arrow is drawn, if the country is kind of small, an inset map is drawn, or if the country is largely water, the bounding box is drawn. These options make the map easier to understand.\n\n::: {#bb54e8ed .cell execution_count=4}\n``` {.python .cell-code}\n    # Set up some basics\n    bounds_increase = 1_500_000\n    country_color = '#DC143C'\n    water_color = '#A7C7E7'\n    land_color = '#DEB887'\n    map_indicator = ''\n\n    # This is the basic set up for all of the plots\n    fig, ax = plt.subplots(subplot_kw={\"projection\": crs})\n    fig.set_size_inches(4, 3)\n    fig.subplots_adjust(0, 0, 1, 1)\n\n    # Space color\n    fig.set_facecolor('#3B3B3B')\n\n    # Equator line\n    ax.gridlines(draw_labels=False,\n                 color='#636363',\n                 linewidth=0.5,\n                 ylocs=[0],\n                 xlocs=[],\n                 linestyle=(0, (5, 5)))\n\n    # location_data buffer for the oceans\n    # 6400000 makes a circle that works a long the edges\n    # used trail and error to find it\n    location_data['geometry'] = location_data['geometry'].buffer(6_400_000)\n    ax.add_geometries(location_data['geometry'],\n                      crs=crs,\n                      color=water_color)\n\n    # Add background world\n    ax.add_geometries(world_ortho[\"geometry\"],\n                      crs=crs,\n                      color=land_color,\n                      edgecolor='black',\n                      linewidth=0.25)\n\n    # Add country map\n    ax.add_geometries(country[\"geometry\"],\n                      crs=crs,\n                      color=country_color,\n                      edgecolor='black',\n                      linewidth=0.25)\n\n    # If the country is very small (just Vatican city), use an arrow to mark it\n    if country_size <= 50_000:\n        xcenter = (xmin + xmax) / 2\n        ycenter = (ymin + ymax) / 2\n        ax.annotate(\"\",\n                    xy=(xcenter, ycenter),\n                    xytext=(xcenter, ycenter + 450_000),\n                    arrowprops=dict(arrowstyle=\"->\",\n                                    connectionstyle=\"arc3\",\n                                    color=country_color,\n                                    linewidth=2))\n        map_indicator = 'Arrow'\n\n    # If the country is small, add an inset map\n    elif (country_size <= 22_500_000_000) or (country_size <= 50_000_000_000 and country_proportion <= .01):\n        iax = inset_locator.inset_axes(ax,\n                                       width=1.5,\n                                       height=1.5,\n                                       loc=\"upper right\",\n                                       borderpad=1,\n                                       axes_class=cartopy.mpl.geoaxes.GeoAxes,\n                                       axes_kwargs=dict(xticks=[],\n                                                        yticks=[],\n                                                        projection=crs))\n        iax.gridlines(draw_labels=False,\n                      color='#636363',\n                      linewidth=0.5,\n                      ylocs=[0],\n                      xlocs=[],\n                      linestyle=(0, (5, 5)))\n        iax.add_geometries(location_data['geometry'],\n                           crs=crs,\n                           color=water_color)\n        iax.add_geometries(world_ortho[\"geometry\"],\n                           crs=crs,\n                           color=land_color,\n                           edgecolor='black',\n                           linewidth=0.25)\n        iax.add_geometries(country[\"geometry\"],\n                           crs=crs,\n                           color=country_color,\n                           edgecolor='black',\n                           linewidth=0.25)\n\n        bounds_increase = 55000\n        iax.axis([xmin - bounds_increase,\n                  xmax + bounds_increase,\n                  ymin - bounds_increase,\n                  ymax + bounds_increase])\n        x = [xmin - bounds_increase,\n             xmax + bounds_increase,\n             xmax + bounds_increase,\n             xmin - bounds_increase,\n             xmin - bounds_increase]\n        y = [ymin - bounds_increase,\n             ymin - bounds_increase,\n             ymax + bounds_increase,\n             ymax + bounds_increase,\n             ymin - bounds_increase]\n        ax.plot(x, y, color='k', alpha=0.5, transform=crs)\n        _ = inset_locator.mark_inset(ax, iax,\n                                     loc1=2, loc2=4,\n                                     linewidth=0.5)\n        map_indicator = 'Inset'\n\n        # Reset bounds_increase for final map\n        bounds_increase = 1500000\n\n    # If the country is mostly ocean, add a bounding box\n    elif country_proportion <= .01:\n        bounding_box = box(xmin, ymin, xmax, ymax)\n        bounding_box_gs = gpd.GeoSeries(bounding_box)\n\n        ax.add_geometries(bounding_box_gs,\n                          crs=crs,\n                          facecolor='none',\n                          edgecolor=country_color,\n                          linewidth=0.5)\n        map_indicator = 'Box'\n\n    # Finish out the plot and save it\n    ax.axis(\"equal\")\n    ax.axis([xmin - bounds_increase,\n             xmax + bounds_increase,\n             ymin - bounds_increase,\n             ymax + bounds_increase])\n    plt.savefig(f'plots/{country_name}.png')\n    plt.close(fig)\n\n    country_data[country_a3] = [country_name,\n                            country_size,\n                            country_area,\n                            country_proportion,\n                            map_indicator]\n```\n:::\n\n\n<br>\n<hr>\n<center>\n<h2>Saving Some Data</h2>\n</center>\n<hr>\n\nThroughout this code, some data has been collected. At the end it's saved to a csv used to manually determine cutoffs for mapping options.\n\n::: {#b923c599 .cell execution_count=5}\n``` {.python .cell-code}\n# Save country data\n# useful to determine cutoffs in the code above\ncountry_df = pd.DataFrame.from_dict(country_data, orient='index',\n                                    columns=['Name',\n                                             'Size',\n                                             'Area',\n                                             'Proportion',\n                                             'Indictor'])\n\ncountry_df.to_csv('country_data.csv', index_label='ISO')\n```\n:::\n\n\nHere are some of the plots. The code and the rest of the outputs can be found at the [GitHub repo](https://github.com/WilliamTylerBradley/country_maps). These can be added to an Anki deck using the [Media Import 2 add-on](https://ankiweb.net/shared/info/129299120).\n\n::: {layout-ncol=\"2\"}\n![Algeria](Algeria.png)\n\n![Andorra (shows inset map)](Andorra.png)\n:::\n\n::: {layout-ncol=\"2\"}\n![Antarctica](Antarctica.png)\n\n![Barbados](Barbados.png)\n:::\n\n::: {layout-ncol=\"2\"}\n![Chile (shows background)](Chile.png)\n\n![Cook Islands (shows box)](Cook%20Islands.png)\n:::\n\n::: {layout-ncol=\"2\"}\n![Vatican (shows arrow)](Vatican.png)\n\n![United States](United%20States.png)\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}