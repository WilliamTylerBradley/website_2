{
  "hash": "f35508f7d5e8dca0ec858056533233f0",
  "result": {
    "markdown": "---\ntitle: \"Bertrand Paradox\"\ndescription: \"Generative art based on the Bertrand Paradox\"\ndate: \"2021-08-12\"\ncategories: [R, Generative Art]\nimage: \"thumbnail.jpeg\"\nexecute: \n  eval: false\n---\n\n\nThis project is based on the [Bertrand Paradox](https://en.wikipedia.org/wiki/Bertrand_paradox_(probability)). The Bertrand Paradox deals with patterns that develop from sampling points/chords in a circle. The paradox occurs when different sampling methods seem like they should have the same output but don't. The first method for this project samples two points on the perimeter then connects them to get the line and the midpoint to get the point. The second method samples a radius at a random angle around the circle, then a random distance on that radius for the midpoint. The line at a right angle is the chord. The last method samples a random point at uniform in the circle for the midpoint. Then the line at a right angle to the segment from that point to the center is the chord. Each of these produces a different distribution of lines and points.\n\nThe code can be found [here](https://github.com/WilliamTylerBradley/bertrand_paradox). We'll walk through a subset of it in this post. For each method, we generate some features at random, then get lines and points from them.\n\n<hr>\n<center><h2>Randomization Methods</h2></center>\n<hr>\n\nFor these methods, we'll build a function called `line_points` that takes in the center and radius of the circle along with the features we randomly generated for each method. The function outputs the two endpoints for the chord and the midpoint. After creating `line_points`, we'll generate the random features then run them through `pmap_dfr` from the `purrr` package to apply the `line_points` function.\n\nFor the following code snippets, `circle_h`, `circle_k`, and `circle_radius` are the circle's center x coordinate, center y coordinates, and radius.\n\nFor method 1, we generate the two points on the perimeter as uniform distances from `0` to `2 * pi`. Then we take each of those and convert them to coordinates based on the circle's center and radius. Finally, get the midpoint and return.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Transformation\n## Parameters\n# circle_x is x value of center\n# circle_y is y value of center\n# circle_radius is radius\n# point_1 is one point from 0 to 2*pi\n# point_2 is one point from 0 to 2*pi\n## Returns\n# dataframe with\n# point_1_x, point_1_y, point_2_x, point_2_y, midpoint_x, midpoint_y\nline_points <- function(circle_x, circle_y, circle_radius, point_1, point_2) {\n  # Get x,y values\n  point_1_x = circle_x + circle_r * cos(point_1)\n  point_1_y = circle_y + circle_r * sin(point_1)\n  point_2_x = circle_x + circle_r * cos(point_2)\n  point_2_y = circle_y + circle_r * sin(point_2)\n  \n  # Get midpoints\n  midpoint_x = (point_1_x + point_2_x) / 2\n  midpoint_y = (point_1_y + point_2_y) / 2\n  \n  return(data.frame(point_1_x = point_1_x,\n                    point_1_y = point_1_y,\n                    point_2_x = point_2_x, \n                    point_2_y = point_2_y,\n                    midpoint_x = midpoint_x,\n                    midpoint_y = midpoint_y))\n}\n\n##-------------\n# Dataset setup\n##-------------\nlines <- data.frame(line = seq(1, n_lines),\n                    point_1 = runif(n_lines, 0, 2 * pi),\n                    point_2 = runif(n_lines, 0, 2 * pi))\n\nlines <- lines %>%\n  bind_cols(pmap_dfr(list(circle_x = circle_h,\n                          circle_y = circle_k,\n                          circle_radius = circle_r, \n                          point_1 = .$point_1,\n                          point_2 = .$point_2), line_points))\n```\n:::\n\n\nFor method 2, our `line_points` function needs a radius (random uniform from `0` to `2 * pi`) and the proportionate distance from the center to the perimeter (random uniform from `0` to `1`). The `line_points` function takes those values, converts the proportion to the actual distance, finds the ends of a chord crossing that point if the angle was 0, rotates everything to the appropriate angle, then moves to the circle's location.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Transformation\n## Parameters\n# circle_x is x value of center\n# circle_y is y value of center\n# circle_radius is radius\n# radius is radian\n# chord is fraction along the radius \n## Returns\n# dataframe with\n# point_1_x, point_1_y, point_2_x, point_2_y, midpoint_x, midpoint_y\nline_points <- function(circle_x, circle_y, circle_radius, radius, chord) {\n  # move out to radius from origin\n  x_1 = circle_radius * cos(radius)\n  y_1 = circle_radius * sin(radius)\n  x_2 = circle_radius * cos(radius)\n  y_2 = circle_radius * sin(radius)\n  \n  # https://www.mathsisfun.com/algebra/trig-solving-ssa-triangles.html\n  # we know one angle is 90*\n  # one side is circle_radius\n  # one side is chord\n  new_angle = pi - pi/2 - asin(((chord * circle_radius) * \n                                  sin(pi/2)) / circle_radius)\n  \n  # now rotate these points around to the radius\n  x_1_moved = cos(new_angle) * x_1 - sin(new_angle) * y_1\n  y_1_moved = sin(new_angle) * x_1 + cos(new_angle) * y_1\n  x_2_moved = cos(-new_angle) * x_2 - sin(-new_angle) * y_2\n  y_2_moved = sin(-new_angle) * x_2 + cos(-new_angle) * y_2\n  \n  # move back to where the circle is\n  x_1_moved = x_1_moved + circle_x\n  y_1_moved = y_1_moved + circle_y\n  x_2_moved = x_2_moved + circle_x\n  y_2_moved = y_2_moved + circle_y\n  \n  return(data.frame(point_1_x = x_1_moved,\n                    point_1_y = y_1_moved,\n                    point_2_x = x_2_moved, \n                    point_2_y = y_2_moved,\n                    midpoint_x = (x_1_moved + x_2_moved) / 2,\n                    midpoint_y = (y_1_moved + y_2_moved) / 2))\n}\n\n##-------------\n# Dataset setup\n##-------------\nlines <- data.frame(line = seq(1, n_lines),\n                    radius = runif(n_lines, 0, 2*pi),\n                    chord = runif(n_lines, 0, 1))\nlines <- lines %>%\n  bind_cols(pmap_dfr(list(circle_x = circle_h,\n                          circle_y = circle_k,\n                          circle_radius = circle_r, \n                          radius = .$radius,\n                          chord = .$chord), line_points))\n```\n:::\n\n\nFor method 3, `line_points` now needs a point's x and y coordinates in the unit circle. We then find the chord by rotating the point to angle 0 then finding the vertical line through that point. The chord's endpoints are where the vertical line crosses the circle. We then rotate those points back, so their midpoint matches the original point.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Transformation\n## Parameters\n# circle_x is x value of center\n# circle_y is y value of center\n# circle_radius is radius\n# point_x is the x value of the random point\n# point_y is the y value of the random point\n## Returns\n# dataframe with\n# point_1_x, point_1_y, point_2_x, point_2_y, midpoint_x, midpoint_y\nline_points <- function(circle_x, circle_y, circle_radius, point_x, point_y) {\n  # move out to radius from origin\n  point_x = circle_radius * point_x\n  point_y = circle_radius * point_y\n  \n  # rotate so just dealing with y\n  flatten_by = atan2(point_y, point_x)\n  \n  # now rotate these points around to the radius\n  x_rotated = cos(-flatten_by) * point_x - sin(-flatten_by) * point_y\n  y_rotated = sin(-flatten_by) * point_x + cos(-flatten_by) * point_y # Should be zero\n  \n  # find y values \n  # x^2 + y^2 = r^2\n  # y^2 = r^2 - x^2\n  # y = +/- sqrt(r^2 - x^2)\n  y1 = sqrt(circle_radius^2 - x_rotated^2)\n  y2 = -sqrt(circle_radius^2 - x_rotated^2)\n  \n  # rotate back\n  point_1_x = cos(flatten_by) * x_rotated - sin(flatten_by) * y1\n  point_1_y = sin(flatten_by) * x_rotated + cos(flatten_by) * y1\n  point_2_x = cos(flatten_by) * x_rotated - sin(flatten_by) * y2\n  point_2_y = sin(flatten_by) * x_rotated + cos(flatten_by) * y2\n\n  # move back to where the circle is\n  point_1_x = point_1_x + circle_x\n  point_1_y = point_1_y + circle_y\n  point_2_x = point_2_x + circle_x\n  point_2_y = point_2_y + circle_y\n  \n  return(data.frame(point_1_x = point_1_x,\n                    point_1_y = point_1_y,\n                    point_2_x = point_2_x, \n                    point_2_y = point_2_y,\n                    midpoint_x = (point_1_x + point_2_x) / 2,\n                    midpoint_y = (point_1_y + point_2_y) / 2))\n}\n\n##-------------\n# Dataset setup\n##-------------\nlines <- data.frame(line = seq(1, n_lines),\n                    r = sqrt(runif(n_lines, 0, 1)),\n                    theta = runif(n_lines, 0, 2*pi))\nlines <- lines %>%\n  mutate(point_x = r * cos(theta),\n         point_y = r * sin(theta)) %>%\n  select(line, point_x, point_y)\nlines <- lines %>%\n  bind_cols(pmap_dfr(list(circle_x = circle_h,\n                          circle_y = circle_k,\n                          circle_radius = circle_r, \n                          point_x = .$point_x,\n                          point_y = .$point_y), line_points))\n```\n:::\n\n\nNow that we have the basic attributes for the three methods, we can talk about coloring them. \n\n<hr>\n<center><h2>Color Selection</h2></center>\n<hr>\n\nFor the methods, I wanted each one to be colored based on different hues. So, I selected them from a yellow-orange/blue-green/purple-red triad. The colors are sampled from ellipses in the HCL color space. The following images show samples from the same ellipses. The line colors are on top and points on the bottom.\n\n::: {layout-ncol=3}\n![Method 1: Colors](1_2_info.jpeg)\n\n![Method 2: Colors](3_4_info.jpeg)\n\n![Method 3: Colors](5_6_info.jpeg)\n:::\n\nIn addition to the lines having a lower base Luminance value, the lines' ellipses are tilted down towards the center while the points' slope upwards on the Chroma-Luminance plane for their respective Hue values. \n\n::: {layout-ncol=3}\n![](1_c_l.jpeg)\n\n![](3_c_l.jpeg)\n\n![](5_c_l.jpeg)\n:::\n\n::: {layout-ncol=3}\n![Method 1: Chroma-Luminance Plane](2_c_l.jpeg)\n\n![Method 2: Chroma-Luminance Plane](4_c_l.jpeg)\n\n![Method 3: Chroma-Luminance Plane](6_c_l.jpeg)\n:::\n\nEach of the lines is closer to the secondary colors in Hue than the points. For the order, the revolve around the color wheel counter-clockwise. We can see this when looking at the Hue-Chroma plane at their respective Luminance values.\n\n::: {layout-ncol=3}\n![](1_h_c.jpeg)\n\n![](3_h_c.jpeg)\n\n![](5_h_c.jpeg)\n:::\n\n::: {layout-ncol=3}\n![Method 1: Hue-Chroma Plane](2_h_c.jpeg)\n\n![Method 2: Hue-Chroma Plane](4_h_c.jpeg)\n\n![Method 3: Hue-Chroma Plane](6_h_c.jpeg)\n:::\n\nI tried picking the colors by algorithm, but I couldn't get that to work as well as I wanted. I often ended up with too much brown or blue. So, the base colors are hand-picked.\n\n<hr>\n<center><h2>Final Output</h2></center>\n<hr>\n\nNow that we can generate the lines/point and colors let's stick it together. We'll add diagrams towards the bottom of the images to explain the methods along with borders. The [Github repo](https://github.com/WilliamTylerBradley/bertrand_paradox) contains the complete code if you want to see it. The diagrams are affected by the random seed, so any example lines/points can be chosen. I used `grid` for this instead of `ggplot2` because I wanted the points and lines to overlap back and forth. That was easier to do with `grid`. Later I changed and put all the points on top of all the lines, but by then, I had it all done in `grid`. I also found this setup easier to control where to place everything on the page instead of worrying about margins or other artifacts getting in the way.\n\nFrom here to the end are the final products. Better 18\" x 24\" jpeg files can be found  [here](https://github.com/WilliamTylerBradley/bertrand_paradox).\n\n![Method 1](method_1_small.jpeg)\n</br>\n</br>\n![Method 2](method_2_small.jpeg)\n</br>\n</br>\n![Method 3](method_3_small.jpeg)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}