{
  "hash": "743c96a2f4ac10807a39abcf69cd08ad",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Grid Tilings\"\ndescription: \"Tilings based on Multigrids\"\ndate: \"2025-09-03\"\ncategories: [Python]\nimage: \"image_graph.png\"\nexecute: \n  eval: false\njupyter: python3\n---\n\n\n<hr>\n<center>\n<h2>Introduction</h2>\n</center>\n<hr>\n\nI created a Python package for creating tiling patterns using the multigrid method. This post walks through the code, which can be found at this [GitHub repository](https://github.com/WilliamTylerBradley/grid_tilings/tree/main). \n\nThe multigrid method takes several grids of lines and use a repeated formula at each intersection to create a shape. Each line has a number; it's **k-value**. These are the inputs to the formula. A different input to the formula is used for each division of an intersection because the **k-value** changes as the division crosses a line. So, two lines intersecting will have four inputs while three lines will have six. The output of one formula determine a point's location. The points together form one tile. Then, all the tiles together create the final image.\n\nIt's important to realize there are two sets of coordinates. One set for the grids and their lines. Another set for the tiles and their points. These two coordinates do not line up. So an image of the lines laid on top of the tiles won't look right.\n\nThe following resources were incredibly helpful.  \n\n* [*Pattern Collider* by Aatish Bhatia and Henry Reich](https://aatishb.com/patterncollider/)\n\n* [*Pentagrids and Penrose Tilings* by Stacy Mowry and Shriya Shukla](https://web.williams.edu/Mathematics/sjmiller/public_html/hudson/HRUMC-Mowry&Shukla_Pentagrids%20and%20Penrose.pdf)\n\n* [*Penrose Tiling* by Andrejs Treibergs](http://www.math.utah.edu/~treiberg/PenroseSlides.pdf)\n\n* [Properly drawing a Penrose tiling using the pentagrid method](https://math.stackexchange.com/questions/3465244/properly-drawing-a-penrose-tiling-using-the-pentagrid-method)\n\nI recommend reading through them to get an idea of how the setup works.\n\nThe code mostly flows in a nice order. So I'm going to go straight through `grid_tilings.py`.\n\n<br>\n<hr>\n<center>\n<h2>Imports</h2>\n</center>\n<hr>\n\nThe imports show two sets: one to build the classes and the other for plotting.\n\n::: {#f673013d .cell execution_count=1}\n``` {.python .cell-code}\nfrom collections import defaultdict, namedtuple, deque\nfrom itertools import combinations\nfrom math import isclose\nimport uuid\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import LineCollection\nfrom matplotlib.collections import PolyCollection\nfrom matplotlib.patches import Polygon\nimport numpy as np\n```\n:::\n\n\n<br>\n<hr>\n<center>\n<h2>Point Class</h2>\n</center>\n<hr>\n\nThe 'Point' class contains the basic information for a point used for a tile. It takes in the **k-values**, determines the coordinates in the tiling space, and saves everything. These will be saved in a dictionary for use when graphing.\n\n::: {#087cdb8d .cell execution_count=2}\n``` {.python .cell-code}\nclass Point:\n    \"\"\"\n    Point class containing location information.\n\n    Attributes:\n        k_values: Tuple of k value uniquely identifying a point\n        base_location: np.array() location in the tiling space\n        centered_location: np.array() location in the tiling space that\n            has been moved so the base_point is at (0, 0)\n    \"\"\"\n\n    def __init__(self, k_values, cos_list, sin_list, mid_point):\n        \"\"\"\n        Constructor for a Point.\n\n        Args:\n            k_values: Tuple of k value uniquely identifying a point\n            cos_list: cosine values of the Multigrid\n            sin_list: sin values of the Multigrid\n            mid_point: center of the tilings\n        \"\"\"\n\n        self.k_values = k_values\n\n        # Convert k_values in the Multigrid space to a point in the\n        #   tiling space\n        self.base_location = np.array([0, 0], dtype=float)\n        for k, c, s in zip(k_values, cos_list, sin_list):\n            self.base_location += k * np.array([c, s])\n\n        self.centered_location = self.base_location - mid_point\n\n    def __str__(self):\n        return f'{self.k_values}'\n```\n:::\n\n\n<br>\n<hr>\n<center>\n<h2>Line Class</h2>\n</center>\n<hr>\n\nThe 'Line' class stores information for each line. The grids will be made up of these lines. This class uses the standard form of a line to allow both vertical and horizontal lines. There is a function to determine the intersection between itself and another line. There's another function to draw the line, which is helpful when debugging. Finally, there's an exception class for if two lines are equivalent. This can happen when two different grids end up overlapping exactly. For example, one grid going straight up and another going straight down with one unit difference. In these situations, the logic for determining the points will fail. So, it needs to be stopped by the exception.\n\n::: {#574be918 .cell execution_count=3}\n``` {.python .cell-code}\nclass Line:\n    \"\"\"\n    Line class used to build up a Multigrid.\n\n    Follows the standard form a line.\n    a*x + b*y = c\n    This allows for both vertical and horizontal lines.\n\n    Attributes:\n        a: x value\n        b: y value\n        c: constant value, created by adding offset and k value\n        k: k value (optional)\n        grid: grid number (optional)\n        angles: angles of the x-axis\n    \"\"\"\n\n    def __init__(self, a, b, o, k=0, grid=None):\n        \"\"\"\n        Constructor for Line.\n\n        Arg:\n            a: x value\n            b: y value\n            c: constant value, created by adding offset and k value\n            o: k value (optional)\n            grid: grid number (optional)\n        \"\"\"\n\n        self.a = a\n        self.b = b\n        self.c = o + k\n        self.offset = o\n        self.k = k\n        self.grid = grid\n\n        # Determine the angle off horizontal\n        first_angle = np.arctan2(-a, b)\n        if first_angle < 0:\n            second_angle = first_angle + np.pi\n        else:\n            second_angle = first_angle - np.pi\n\n        # crossing counter-clockwise\n        # first angle is always k + 1\n        # second is alway k by construction\n        Angle = namedtuple('Angle', ['value', 'k', 'grid'])\n        self.angles = [Angle(first_angle, self.k + 1, grid),\n                       Angle(second_angle, self.k, grid)]\n\n    def __str__(self):\n        return (f'a={self.a}, b={self.b}, offset={self.offset}, '\n                f'k={self.k}, grid={self.grid}')\n\n    def determine_intersection(self, other_line, decimals=7):\n        \"\"\"\n        Finds the intersection between this Line and another one.\n\n        Args:\n            other_line: different Line\n            decimals: controls the rounding for comparisons\n\n        Returns:\n            Tuple containing the intersection or None if parallel\n\n        Raises:\n            OverlappingLines: if the Lines are the same\n        \"\"\"\n\n        # denominator for formula for the intersection\n        # if this is zero then the lines are parallel or overlap\n        denom = (self.a * other_line.b) - (other_line.a * self.b)\n        if isclose(denom, 0, rel_tol=1e-5, abs_tol=1e-05):\n\n            # Determine if it's the same line by calculating if all the\n            #   coefficients have the same proportion between the two\n            #   lines\n            if isclose(other_line.a, 0, rel_tol=1e-5, abs_tol=1e-05):\n                if not isclose(self.a, 0, rel_tol=1e-5, abs_tol=1e-05):\n                    # Different lines\n                    return None\n                a_proportion = 0\n            else:\n                a_proportion = self.a / other_line.a\n\n            if isclose(other_line.b, 0, rel_tol=1e-5, abs_tol=1e-05):\n                if not isclose(self.b, 0, rel_tol=1e-5, abs_tol=1e-05):\n                    # Different lines\n                    return None\n                b_proportion = 0\n            else:\n                b_proportion = self.b / other_line.b\n\n            if a_proportion and b_proportion:\n                if not isclose(a_proportion, b_proportion):\n                    return None\n\n            if isclose(other_line.c, 0, rel_tol=1e-5, abs_tol=1e-05):\n                if not isclose(self.c, 0, rel_tol=1e-5, abs_tol=1e-05):\n                    # Different lines\n                    return None\n                c_proportion = 0\n            else:\n                c_proportion = self.c / other_line.c\n\n            if a_proportion and c_proportion:\n                if not isclose(a_proportion, c_proportion,\n                               rel_tol=1e-5, abs_tol=1e-05):\n                    return None\n\n            if b_proportion and c_proportion:\n                if not isclose(b_proportion, c_proportion,\n                               rel_tol=1e-5, abs_tol=1e-05):\n                    return None\n\n            raise OverlappingLines(self, other_line)\n        else:\n            x = (other_line.b * self.c) - (self.b * other_line.c)\n            x = x / denom\n\n            y = (self.a * other_line.c) - (other_line.a * self.c)\n            y = y / denom\n\n            return (np.round(x, decimals), np.round(y, decimals))\n\n    def draw_line(self, ax):\n        \"\"\"\n        Draws the line.\n\n        Example:\n            l = Line(1, 1, 0)\n\n            fig, ax = plt.subplots()\n            l.draw_line(ax)\n            plt.show()\n        \"\"\"\n\n        graph_points = []\n\n        # Crosses x-axis\n        if self.b != 0:\n            graph_points.append((-5, (self.c - self.a*-5)/self.b))\n            graph_points.append((0, self.c/self.b))\n            graph_points.append((5, (self.c - self.a*5)/self.b))\n\n        # Crosses y-axis\n        if self.a != 0:\n            graph_points.append(((self.c - self.b*-5)/self.a, -5))\n            graph_points.append((self.c/self.a, 0))\n            graph_points.append(((self.c - self.b*5)/self.a, 5))\n\n        # Build out boundary\n        min_x = np.inf\n        max_x = -np.inf\n        min_y = np.inf\n        max_y = -np.inf\n\n        for i in graph_points:\n            if i[0] < min_x:\n                min_x = i[0]\n            if i[0] > max_x:\n                max_x = i[0]\n            if i[1] < min_y:\n                min_y = i[1]\n            if i[1] > max_y:\n                max_y = i[1]\n\n        # If the line is horizontal or vertical, set boundary to 5.\n        if min_x == max_x:\n            min_x = min_x - 5\n            max_x = max_x + 5\n        if min_y == max_y:\n            min_y = min_y - 5\n            max_y = max_y + 5\n\n        ax.axhline(0, color='gray', linestyle=\"--\")\n        ax.axvline(0, color='gray', linestyle=\"--\")\n        ax.add_collection(LineCollection([graph_points]))\n        ax.set_xlim(min_x, max_x)\n        ax.set_ylim(min_y, max_y)\n        ax.set_aspect('equal')\n        return ax\n\n\nclass OverlappingLines(Exception):\n    \"\"\"Exception for lines that are the same.\"\"\"\n    def __init__(self, line_1, line_2,\n                 msg=\"These two lines are the same line.\"):\n        self.line_1 = line_1\n        self.line_2 = line_2\n        self.msg = msg\n        super().__init__(self.msg)\n\n    def __str__(self):\n        return f'{self.msg}\\n\\t{self.line_1}\\n\\t{self.line_2}'\n```\n:::\n\n\n::: {layout-ncol=\"3\"}\n![(0, 1, 2) Line](line_graph_0_1_2.png)\n\n![(1, 0, 0) Line](line_graph_1_0_0.png)\n\n![(1, 1, 0) Line](line_graph_1_1_0.png)\n:::\n\n<br>\n<hr>\n<center>\n<h2>Edge Class</h2>\n</center>\n<hr>\n\nThe `Edge` class is used to draw the tiles and determine which tiles are neighbors. There is an exception for if an edge is used by more than two tiles. This can happen when there's a floating point issue.\n\n::: {#c59e8010 .cell execution_count=4}\n``` {.python .cell-code}\nclass Edge:\n    \"\"\"\n    Class used for tile edges.\n\n    This doesn't relate to the Line class at all.\n    \"\"\"\n\n    def __init__(self, point_ids, tile_id):\n        \"\"\"\n        Constructor for Edge.\n\n        Args:\n            point_ids: Points for the ends of the edge\n            tile_id: starting tile_id\n        \"\"\"\n        self.points = point_ids\n        self.tile_ids = [tile_id]\n\n    def add_tile_id(self, tile_id):\n        \"\"\"\n        Adds a tile_id to the list of adjacent tiles\n\n        Raises:\n            OverusedEdge: if there are more than two tiles\n        \"\"\"\n        self.tile_ids.append(tile_id)\n\n        if len(self.tile_ids) > 2:\n            raise OverusedEdge(self)\n\n    def __str__(self):\n        msg = f'point_ids: {self.points}'\n        for t in self.tile_ids:\n            msg = msg + f'\\n\\t{t}'\n        return msg\n\n\nclass OverusedEdge(Exception):\n    \"\"\"\n    Exception for when an edge has more than two tiles one it.\n\n    Happens when the floating point fails on a point with multiple lines\n    \"\"\"\n    def __init__(self, edge, msg=\"This edge has more than two tiles.\"):\n        self.edge = edge\n        self.msg = msg\n        super().__init__(self.msg)\n\n    def __str__(self):\n        return f'{self.msg}\\n\\t{self.edge}'\n```\n:::\n\n\n<br>\n<hr>\n<center>\n<h2>Tile Class</h2>\n</center>\n<hr>\n\nThe `Tile` class contains all the information for one shape. It takes in the points and the intersection that creates the tile. The function `compare_angles` compares itself to another tile to see if they match. This function, along with `tile_group`, is used to color all the same tiles one color. Then `draw_tile` and `draw_line_angles` draw images.\n\n::: {#59fa26fe .cell execution_count=5}\n``` {.python .cell-code}\nclass Tile:\n    \"\"\"\n    Class used for the Tile.\n\n    Attributes:\n        tile_points: points around the tile\n        intersection_points: points for the intersection that creates\n            the tile\n        intersection_lines: lines from the Multigrid that intersect on\n            the tile\n        tile_group: group number for coloring similar tiles\n        tile_id: unique id for each tile. Used for Edge class\n        connected: Bool for if the tile is connected to the base_point\n            through other tiles. Used to remove unconnected tiles.\n        interior_angles: angles inside the tile. Used determine similar\n            tiles and thus the tile_group.\n    \"\"\"\n    def __init__(self, tile_points, intersection_points, intersection_lines):\n        \"\"\"\n        Constructor for a Tile\n\n        Args:\n            tile_points: points around the tile\n            intersection_points: points for the intersection that\n                creates the tile\n            intersection_lines: lines from the Multigrid that intersect\n                on the tile\n        \"\"\"\n        self.tile_points = tile_points\n        self.intersection_points = intersection_points\n        self.intersection_lines = intersection_lines\n        self.tile_group = 0\n        self.tile_id = uuid.uuid4()\n        self.connected = False\n\n        # Determine the interior angles to compare tiles to see which\n        #   ones have the same shape. Don't need to compare distances\n        #   between angles because it's always 1 by construction.\n        self.interior_angles = []\n        for previous_point, tile_point, next_point in (\n            zip([self.tile_points[-1]] + self.tile_points[:-1],\n                self.tile_points,\n                self.tile_points[1:] + [self.tile_points[0]])):\n\n            point_location = tile_point.base_location\n            previous_point_location = previous_point.base_location\n            next_point_location = next_point.base_location\n\n            in_vector = point_location - previous_point_location\n            out_vector = next_point_location - point_location\n            angle = np.arctan2(in_vector[0] * out_vector[1]\n                               - in_vector[1] * out_vector[0],\n                               in_vector[0] * out_vector[0]\n                               + in_vector[1] * out_vector[1])\n\n            self.interior_angles.append(angle)\n\n    def compare_angles(self, other_polygon):\n        \"\"\"\n        Compare this tile to another one to see if they have the\n            same shape\n        \"\"\"\n\n        # Do they even have the same number of angles?\n        if len(self.interior_angles) != len(other_polygon.interior_angles):\n            return False\n\n        # Is the first angle even in the other set?\n        no_match = True\n        for a in self.interior_angles:\n            if isclose(a, other_polygon.interior_angles[0],\n                       rel_tol=1e-5, abs_tol=1e-05):\n                no_match = False\n        if no_match:\n            return False\n\n        # Do they have all the same angles in same order?\n        angles_repeated = self.interior_angles + self.interior_angles\n        for a in np.arange(len(self.interior_angles)):\n            match = True\n            for b in np.arange(len(other_polygon.interior_angles)):\n                if not isclose(angles_repeated[a + b],\n                               other_polygon.interior_angles[b],\n                               rel_tol=1e-5, abs_tol=1e-05):\n                    match = False\n                    break\n            if match:\n                return True\n        return False\n\n    def draw_tile(self, ax):\n        \"\"\"\n        Draws the tile.\n\n        Example:\n            cos_list = [1, 0, -1, 0]\n            sin_list = [0, 1, 0, -1]\n            mid_point = np.array([0, 0], dtype=float)\n\n            points = [Point((1.0, 0.0, 0.0, 0.0),\n                            cos_list,\n                            sin_list,\n                            mid_point),\n                    Point((1.0, 1.0, 0.0, 0.0),\n                          cos_list,\n                          sin_list,\n                          mid_point),\n                    Point((0.0, 1.0, 0.0, 0.0),\n                          cos_list,\n                          sin_list,\n                          mid_point),\n                    Point((0.0, 0.0, 0.0, 0.0),\n                          cos_list,\n                          sin_list,\n                          mid_point)]\n            lines = [Line(0, 1, .25, 0, 1),\n                    Line(1, 0, .25, 0, 2)]\n            t = Tile(points, (.25, .25), lines)\n            fig, ax = plt.subplots()\n            t.draw_tile(ax)\n            plt.show()\n        \"\"\"\n\n        # Determine boundary box\n        min_x = np.inf\n        max_x = -np.inf\n        min_y = np.inf\n        max_y = -np.inf\n\n        line_base_point = self.intersection_points\n        tile_points = []\n        for tp in self.tile_points:\n            if tp.base_location[0] < min_x:\n                min_x = tp.base_location[0]\n            if tp.base_location[0] > max_x:\n                max_x = tp.base_location[0]\n            if tp.base_location[1] < min_y:\n                min_y = tp.base_location[1]\n            if tp.base_location[1] > max_y:\n                max_y = tp.base_location[1]\n            tile_points.append(tp.base_location.copy())\n\n        midpoint_x = 0\n        midpoint_y = 0\n\n        for p in tile_points:\n            midpoint_x += p[0]\n            midpoint_y += p[1]\n\n        midpoint_x = midpoint_x / len(tile_points)\n        midpoint_y = midpoint_y / len(tile_points)\n\n        for p in tile_points:\n            p[0] = p[0] - midpoint_x + line_base_point[0]\n            p[1] = p[1] - midpoint_y + line_base_point[1]\n\n        min_x -= 1\n        max_x += 1\n        min_y -= 1\n        max_y += 1\n\n        # Line stuff\n        line_base_point = self.intersection_points\n        line_min_x = self.intersection_points[0] - 2\n        line_max_x = self.intersection_points[0] + 2\n        line_min_y = self.intersection_points[1] - 2\n        line_max_y = self.intersection_points[1] + 2\n        boundary = [Line(1, 0, line_min_x, 0),\n                    Line(1, 0, line_max_x, 0),\n                    Line(0, 1, line_min_y, 0),\n                    Line(0, 1, line_max_y, 0)]\n\n        draw_lines = []\n\n        for line in self.intersection_lines:\n            points = []\n            for b in boundary:\n                intersection = line.determine_intersection(b)\n                if (intersection\n                        and intersection[0] >= (line_min_x - .5)\n                        and intersection[0] <= (line_max_x + .5)\n                        and intersection[1] >= (line_min_y - .5)\n                        and intersection[1] <= (line_max_y + .5)):\n                    points.append(intersection)\n            draw_lines.append(points)\n\n        ax.add_collection(LineCollection(draw_lines))\n        ax.add_patch(Polygon(tile_points, facecolor='w', edgecolor=\"k\"))\n        ax.set_xlim(line_min_x, line_max_x)\n        ax.set_ylim(line_min_y, line_max_y)\n        ax.set_aspect('equal')\n\n        return ax\n\n    def draw_line_angles(self, ax):\n        \"\"\"Draws the lines and their angles.\"\"\"\n\n        angles = [np.pi * x / 4 for x in range(-4, 4, 1)]\n        angles_color = ['black' for x in angles]\n\n        for line in self.intersection_lines:\n            angles.extend([line.angles[0].value, line.angles[1].value])\n            angles_color.extend(['red', 'red'])\n\n        draw_lines = []\n        text_location = []\n\n        for angle in angles:\n            draw_lines.append([(0, 0), (np.cos(angle), np.sin(angle))])\n            text_location.append([1.10 * np.cos(angle), 1.10 * np.sin(angle)])\n\n        ax.add_collection(LineCollection(draw_lines, colors=angles_color))\n        for tl, a in zip(text_location, angles):\n            ax.text(tl[0], tl[1], f'{a:.2f}')\n        ax.set_xlim(-1.5, 1.5)\n        ax.set_ylim(-1.5, 1.5)\n        ax.axis('off')\n        ax.set_aspect('equal')\n\n        return ax\n```\n:::\n\n\n::: {layout-ncol=\"2\"}\n![Intersection Angles](tile_line_angles_graph.png)\n\n![Tile](tile_graph.png)\n:::\n\n<br>\n<hr>\n<center>\n<h2>Multigrid Class</h2>\n</center>\n<hr>\n\nThe `Multigrid` class is the workhorse of this package. It takes in all the starting parameters and sets up the grid. The `create_tiles` function finds all the intersections, creates a tile for each one, then assigns the tile a color. The `remove_unconnected_tiles` function discards any tiles that don't connect to the main central section. The `draw_image` and `save_image` function create the final images. The `determine_base_K` and `determine_K` functions are used to determine the *k-values*. The `random_color` and `oklab` functions are used to create colors. Finally, the `draw_oklab`, `draw_offsets`, `draw_grids`, `draw_k`, and `draw_all_tiles` functions are helpers to visualize the process.\n\n::: {#4cc63cc5 .cell execution_count=6}\n``` {.python .cell-code}\nclass Multigrid:\n    \"\"\"\n    Multigrid class used create the grid of Lines to create the Tiles.\n\n    This is the main workhorse for the package.\n\n    Attributes:\n        seed: RNG seed\n        grid_count: The number of grids\n        grid_bounds: The number of lines in a grid\n        rotation: Amount to turn the multigrid\n        cos_list: cosine values of the Multigrid\n        sin_list: sin values of the Multigrid\n        base_point: Location to move the multigrid to\n        offsets: Movement from the center for each of the grids\n        colors: Colors for the tile groups\n        grids: list for all of the Lines in the Multigrid\n        grid_colors: list for a color for each grid\n        mid_point: center of the tilings\n        points: dictionary of the points for the Tiles\n        edges: dictionary of the edges for the Tiles\n        intersections: dictionary for the intersections between all the\n            Lines in the Multigrid\n        base_tiles: tile of unique tile shapes, used to determine Tile\n            coloring\n        tiles: dictionary of Tiles\n    \"\"\"\n\n    def __init__(self,\n                 seed=None,\n                 grid_count=None,\n                 grid_bounds=[],\n                 rotation=None,\n                 base_point=(),\n                 offsets=[],\n                 colors=[]):\n        \"\"\"\n        Constructor for a Multigrid\n\n        Args:\n            seed: RNG seed\n            grid_count: The number of grids\n            grid_bounds: The number of lines in a grid\n            rotation: Amount to turn the multigrid\n            base_point: Location to move the multigrid to\n            offsets: Movement from the center for each of the grids\n            colors: Colors for the tile groups\n        \"\"\"\n        self.seed = seed\n        self.rng = np.random.default_rng(self.seed)\n\n        if not grid_count:\n            grid_count = self.rng.integers(low=5, high=20)\n        self.grid_count = grid_count\n\n        if not grid_bounds:\n            grid_bounds = self.rng.integers(low=2, high=10)\n            grid_bounds = [-grid_bounds, grid_bounds+1]\n        self.grid_bounds = grid_bounds\n\n        if rotation is None:\n            rotation = self.rng.uniform(low=0, high=(2 * np.pi / grid_count))\n        self.rotation = rotation\n\n        # Evenly space grids around the origin\n        self.cos_list = [np.cos(x * 2 * np.pi\n                                / self.grid_count + self.rotation)\n                         for x in np.arange(self.grid_count)]\n        self.sin_list = [np.sin(x * 2 * np.pi\n                                / self.grid_count + self.rotation)\n                         for x in np.arange(self.grid_count)]\n\n        if not offsets:\n            offsets = self.rng.uniform(size=grid_count)\n            if sum(offsets) != 0:\n                offsets = offsets / sum(offsets)\n        self.offsets = offsets\n\n        if colors:\n            self.colors = colors\n        else:\n            self.colors = []\n\n        if not base_point:\n            r = 25 * np.sqrt(self.rng.random())\n            theta = self.rng.random() * 2 * np.pi\n            base_point = np.array([r * np.cos(theta),\n                                   r * np.sin(theta), 0], dtype=float)\n        self.base_point = base_point\n\n        base_k_values = []\n        for c, s, o in zip(self.cos_list, self.sin_list, offsets):\n            base_k_values.append(\n                self.determine_base_K(self.base_point, c, s, o))\n\n        # Create the grids here\n        self.grids = []\n        for i, (s, c, o, bk) in enumerate(zip(self.sin_list, self.cos_list,\n                                              offsets, base_k_values)):\n            for k in np.arange(*grid_bounds):\n                self.grids.append(Line(c, s, o, bk + k, i))\n        self.grid_colors = [self.oklab(.75, .1 * c, .1 * s)\n                            for c, s in zip(self.cos_list, self.sin_list)]\n\n        self.mid_point = np.array([0, 0], dtype=float)\n        for k, c, s in zip(base_k_values, self.cos_list, self.sin_list):\n            self.mid_point += k * np.array([c, s])\n\n    def update_edges(self, points, tile_id):\n        \"\"\"Only used to update edges when creating tiles\"\"\"\n        if points in self.edges:\n            self.edges[points].add_tile_id(tile_id)\n        else:\n            self.edges[points] = Edge(points, tile_id)\n\n    def create_tiles(self):\n        \"\"\"\n        Creates the tiles from the intersections of lines in the\n            Multigrid\n        \"\"\"\n\n        self.points = {}\n\n        self.edges = {}\n\n        # Use a set for each intersection so if three or more lines\n        #   cross at the same point, there is one intersection and only\n        #   those many lines listed, not an intersection for each pair\n        #   of lines\n        self.intersections = defaultdict(set)\n        for pair in combinations(self.grids, 2):\n            l1 = pair[0]\n            l2 = pair[1]\n\n            # If they're the same grid, they don't intersect\n            if l1.grid == l2.grid:\n                continue\n\n            try:\n                intersection = l1.determine_intersection(l2)\n                # Sometime there's not an intersection for even number\n                #   grids.\n                if intersection:\n                    self.intersections[intersection].update([l1, l2])\n            # A bad combination of offsets with an even number of grids\n            #   can produce lines that overlap (because two grids end up\n            #   one unit apart, but in the exact opposite direction).\n            #   If that happens, it should break.\n            except OverlappingLines as e:\n                print(e)\n                raise\n\n        self.base_tiles = []\n        self.tiles = {}\n\n        for (intersection_points,\n             intersection_lines) in self.intersections.items():\n\n            # We need to build a tile from each intersection. The points\n            #   of a tile are in between the lines that make up an\n            #   intersection. We'll loop through the lines in circle\n            #   crossing over each line and then back over them as we\n            #   go all the way around. So first order the lines by\n            #   angle.\n            angles = []\n            for line in intersection_lines:\n                angles.extend(line.angles.copy())\n            angles.sort()\n\n            # Then, set up K values for the other lines. The k values\n            #   that are for the lines get pulled from them.\n            ks = [self.determine_K(c, intersection_points[0],\n                                   s, intersection_points[1], o)\n                  for c, s, o in zip(self.cos_list,\n                                     self.sin_list,\n                                     self.offsets)]\n\n            # Now spin around to ensure the ks are correct on the lines\n            #   that intersect for the starting point (the left side of\n            #   the circle).\n            for angle in angles:\n                ks[angle.grid] = angle.k\n\n            # Finally, loop through again with all the k values set\n            #   correctly, update them as each line is crossed.\n            tile_points = []\n            for angle in angles:\n                ks[angle.grid] = angle.k\n\n                k_values = tuple(ks)\n                if k_values not in self.points:\n                    self.points[k_values] = Point(k_values,\n                                                  self.cos_list,\n                                                  self.sin_list,\n                                                  self.mid_point)\n\n                tile_points.append(self.points[k_values])\n\n            t = Tile(tile_points, intersection_points, intersection_lines)\n\n            # Create an Edge for each edge of a Tile\n            for t_current, t_next in zip(t.tile_points,\n                                         t.tile_points[1:]\n                                         + [t.tile_points[0]]):\n                # Check left to right, then down to up to make sure the\n                #   edges dictionary keys match\n                if t_current.base_location[1] < t_next.base_location[1]:\n                    self.update_edges(points=(t_current.k_values,\n                                              t_next.k_values),\n                                      tile_id=t.tile_id)\n                elif t_next.base_location[1] < t_current.base_location[1]:\n                    self.update_edges(points=(t_next.k_values,\n                                              t_current.k_values),\n                                      tile_id=t.tile_id)\n                elif t_current.base_location[0] < t_next.base_location[0]:\n                    self.update_edges(points=(t_current.k_values,\n                                              t_next.k_values),\n                                      tile_id=t.tile_id)\n                else:\n                    self.update_edges(points=(t_next.k_values,\n                                              t_current.k_values),\n                                      tile_id=t.tile_id)\n\n            # Assign a tile_group number for coloring later\n            bt_match = False\n            for bt in self.base_tiles:\n                if bt.compare_angles(t):\n                    t.tile_group = bt.tile_group\n                    bt_match = True\n                    break\n\n            if not bt_match:\n                t.tile_group = len(self.base_tiles)\n                self.base_tiles.append(t)\n\n            self.tiles[t.tile_id] = t\n\n        # Assign colors to base tiles\n        if not self.colors:\n            for i in range(len(self.base_tiles) + 1):\n                self.colors.append(self.random_color())\n\n    def remove_unconnected_tiles(self):\n        \"\"\"\n        Removes tiles that aren't connected to the center.\n\n        Only needed if drawing all tiles and don't want any of the\n        unconnected ones.\n        \"\"\"\n\n        # Build out network of neighbors\n        neighbors = defaultdict(list)\n        for edge in self.edges.values():\n            if len(edge.tile_ids) == 2:\n                neighbors[edge.tile_ids[0]].append(edge.tile_ids[1])\n                neighbors[edge.tile_ids[1]].append(edge.tile_ids[0])\n\n        # Find a center-ish tile\n        for tile_id, tile in self.tiles.items():\n            tile_point = tile.tile_points[0]\n            tile_distance = tile_point.centered_location[0]**2\n            + tile_point.centered_location[1]**2\n            if tile_distance < 1.5:\n                center_tile = tile\n                break\n\n        # Mark the connected tiles\n        center_tile.connected = True\n        connected_tiles = deque([center_tile])\n\n        while connected_tiles:\n            current_tile = connected_tiles.pop()\n            for neighbor in neighbors[current_tile.tile_id]:\n                neighbor_tile = self.tiles[neighbor]\n                if not neighbor_tile.connected:\n                    neighbor_tile.connected = True\n                    connected_tiles.append(neighbor_tile)\n\n        # Now, delete the not connected tiles\n        for k in list(self.tiles.keys()):\n            if not self.tiles[k].connected:\n                del self.tiles[k]\n\n        remove_edges = []\n        for edge in self.edges.values():\n            for t in edge.tile_ids.copy():\n                if t not in self.tiles:\n                    edge.tile_ids.remove(t)\n\n            if not edge.tile_ids:\n                remove_edges.append(edge.points)\n\n        for edge in remove_edges:\n            del self.edges[edge]\n\n    def draw_image(self, ax):\n        \"\"\"\n        Draws the main image.\n\n        mg = Multigrid(grid_count=5,\n                            grid_bounds=[-5, 5], rotation=0,\n                            base_point = [0, 0],\n                            offsets=[.2, .2, .2, .2, .2])\n        mg.create_tiles()\n        mg.remove_unconnected_tiles()\n        fig, ax = plt.subplots(figsize=figsize)\n        ax = self.draw_image(ax)\n        plt.tight_layout()\n        plt.show()\n        \"\"\"\n        # Find the closest distance between the center and all the edges\n        #   that don't have two tiles\n        closest_distance = np.inf\n\n        for edge in self.edges.values():\n            if len(edge.tile_ids) == 1:\n                for p in edge.points:\n                    p_distance = (self.points[p].centered_location[0] ** 2\n                                  + self.points[p].centered_location[1] ** 2)\n                    if p_distance < closest_distance:\n                        closest_distance = p_distance\n        closest_distance = np.sqrt(closest_distance)\n\n        # Set this distance as the diagonal of a square for the image\n        #   bounds.\n        image_bounds = closest_distance / np.sqrt(2)\n\n        # Set up all the tiles as polygons\n        polygons = []\n        polygon_colors = []\n        for t in self.tiles.values():\n            locations = []\n            for p in t.tile_points:\n                locations.append(p.centered_location)\n\n            polygons.append(locations)\n            polygon_colors.append(self.colors[t.tile_group])\n\n        polygon_collection = PolyCollection(polygons,\n                                            facecolor=polygon_colors,\n                                            edgecolor=self.colors[-1])\n        ax.add_collection(polygon_collection)\n        ax.set_aspect('equal')\n        ax.axis([-image_bounds, image_bounds, -image_bounds, image_bounds])\n        ax.axis('off')\n\n    def save_image(self, image_location, figsize=(5, 5), dpi=150):\n        \"\"\"\n        Save the main image\n\n        mg = Multigrid(grid_count=5,\n                            grid_bounds=[-5, 5], rotation=0,\n                            base_point = [0, 0],\n                            offsets=[.2, .2, .2, .2, .2])\n        mg.create_tiles()\n        mg.remove_unconnected_tiles()\n        mg.save_image('output/graph.png')\n        \"\"\"\n\n        fig, ax = plt.subplots(figsize=figsize)\n        self.draw_image(ax)\n        plt.tight_layout(pad=0)\n        plt.savefig(image_location, dpi=dpi)\n        plt.close()\n\n    def determine_base_K(self, p, c, s, o):\n        \"\"\"Set the k values if there's a base_point\"\"\"\n        # If it's on a line, lower it to the origin\n        if isclose(((c * p[0] + s * p[1]) % 1), o,\n                   rel_tol=1e-5, abs_tol=1e-05):\n            p_distance = np.sqrt(p[0]**2 + p[1]**2)\n            if p_distance:\n                p_normal_origin = [-p_ / p_distance * .5 for p_ in p]\n                p = [p + pno for p, pno in zip(p, p_normal_origin)]\n            else:\n                return 0\n\n        base_k = self.determine_K(c, p[0], s, p[1], o)\n        return base_k\n\n    def determine_K(self, c, x, s, y, o):\n        \"\"\"Formula for the k values\"\"\"\n        return np.ceil(c * x + s * y - o)\n\n    def random_color(self):\n        \"\"\"Draws a random color from oklab\"\"\"\n        converts_rgb = False\n\n        while not converts_rgb:\n            L = self.rng.uniform(0, 1)\n            a = self.rng.uniform(-.3, .3)\n            b = self.rng.uniform(-.3, .3)\n\n            rgb = self.oklab(L, a, b)\n\n            if ((0 <= rgb[0] and rgb[0] <= 1)\n                    and (0 <= rgb[1] and rgb[1] <= 1)\n                    and (0 <= rgb[2] and rgb[2] <= 1)):\n                converts_rgb = True\n\n        return rgb\n\n    def oklab(self, L, a, b):\n        \"\"\"Converts oklab to rgb\"\"\"\n        new_l = L + 0.3963377774 * a + 0.2158037573 * b\n        new_m = L - 0.1055613458 * a - 0.0638541728 * b\n        new_s = L - 0.0894841775 * a - 1.2914855480 * b\n\n        new_l = new_l * new_l * new_l\n        new_m = new_m * new_m * new_m\n        new_s = new_s * new_s * new_s\n\n        rgb = [4.0767416621 * new_l\n               - 3.3077115913 * new_m\n               + 0.2309699292 * new_s,\n               -1.2684380046 * new_l\n               + 2.6097574011 * new_m\n               - 0.3413193965 * new_s,\n               -0.0041960863 * new_l\n               - 0.7034186147 * new_m\n               + 1.7076147010 * new_s]\n\n        # transfer function\n        rgb_correct = []\n        for value in rgb:\n            if value <= .0031308:\n                value = 12.92 * value\n            else:\n                value = (1.055 * np.power(value, (1 / 2.4))) - 0.055\n            rgb_correct.append(value)\n\n        return rgb_correct\n\n    def draw_oklab(self, L):\n        \"\"\"Draws a slice of oklab colorspace\"\"\"\n        A, B = np.meshgrid(np.arange(-.3, .3, .001), np.arange(-.3, .3, .001))\n        r = np.zeros_like(A)\n        g = np.zeros_like(A)\n        b = np.zeros_like(A)\n        a = np.zeros_like(A)\n        for i in range(len(r)):\n            for j in range(len(r[0])):\n                rgb = self.oklab(L, A[i, j], B[i, j])\n\n                if ((0 <= rgb[0] and rgb[0] <= 1)\n                        and (0 <= rgb[1] and rgb[1] <= 1)\n                        and (0 <= rgb[2] and rgb[2] <= 1)):\n                    r[i, j] = rgb[0]\n                    g[i, j] = rgb[1]\n                    b[i, j] = rgb[2]\n                    a[i, j] = 1\n\n        c = np.dstack([r, g, b, a])\n\n        plt.imshow(c, interpolation='nearest', origin=\"lower\")\n        plt.xlabel('a')\n        plt.xticks(np.linspace(0, len(c), 7),\n                   labels=np.round(np.linspace(-.3, .3, 7), 2))\n        plt.ylabel('b')\n        plt.yticks(np.linspace(0, len(c), 7),\n                   labels=np.round(np.linspace(-.3, .3, 7), 2))\n        plt.title(f\"L = {L}\")\n        plt.show()\n\n    def draw_offsets(self, ax):\n        \"\"\"Draws the offsets\"\"\"\n        x = [x * o + self.base_point[0] for x, o in\n             zip(self.cos_list, self.offsets)]\n        y = [y * o + self.base_point[1] for y, o in\n             zip(self.sin_list, self.offsets)]\n\n        for x_point, y_point in zip(x, y):\n            ax.annotate(\"\", xytext=self.base_point, xy=(x_point, y_point),\n                        arrowprops=dict(arrowstyle=\"->\"))\n        ax.scatter(self.base_point[0], self.base_point[1])\n        ax.scatter(x, y)\n        ax.set_aspect('equal', 'box')\n        return ax\n\n    def draw_grids(self, ax):\n        \"\"\"Draws the grids\"\"\"\n        min_x = np.inf\n        max_x = -np.inf\n        min_y = np.inf\n        max_y = -np.inf\n\n        for i in self.intersections.keys():\n            if i[0] < min_x:\n                min_x = i[0]\n            if i[0] > max_x:\n                max_x = i[0]\n            if i[1] < min_y:\n                min_y = i[1]\n            if i[1] > max_y:\n                max_y = i[1]\n\n        min_x -= 1\n        max_x += 1\n        min_y -= 1\n        max_y += 1\n\n        boundary = [Line(1, 0, min_x, 0), Line(1, 0, max_x, 0),\n                    Line(0, 1, min_y, 0), Line(0, 1, max_y, 0)]\n\n        draw_lines = []\n        draw_color = []\n\n        for line in self.grids:\n            points = []\n            for b in boundary:\n                intersection = line.determine_intersection(b)\n                if (intersection\n                        and intersection[0] >= (min_x - .5)\n                        and intersection[0] <= (max_x + .5)\n                        and intersection[1] >= (min_y - .5)\n                        and intersection[1] <= (max_y + .5)):\n                    points.append(intersection)\n            draw_lines.append(points)\n            draw_color.append(line.grid)\n\n        colors = [self.grid_colors[g] for g in draw_color]\n        ax.add_collection(LineCollection(draw_lines, colors=colors))\n\n        ax.set_xlim(min_x, max_x)\n        ax.set_ylim(min_y, max_y)\n        ax.set_aspect('equal')\n        return ax\n\n    def draw_k(self, ax, this_grid):\n        \"\"\"Draws the k values for one grid\"\"\"\n        these_lines = [line for line in self.grids if line.grid == this_grid]\n        this_cos = self.cos_list[this_grid]\n        this_sin = self.sin_list[this_grid]\n        this_offset = self.offsets[this_grid]\n\n        min_x = np.floor(self.base_point[0] - self.grid_count - 1)\n        max_x = np.ceil(self.base_point[0] + self.grid_count + 1)\n        min_y = np.floor(self.base_point[1] - self.grid_count - 1)\n        max_y = np.ceil(self.base_point[1] + self.grid_count + 1)\n\n        boundary = [Line(1, 0, min_x, 0), Line(1, 0, max_x, 0),\n                    Line(0, 1, min_y, 0), Line(0, 1, max_y, 0)]\n\n        draw_lines = []\n        draw_color = []\n\n        for line in these_lines:\n            points = []\n            for b in boundary:\n                intersection = line.determine_intersection(b)\n                if (intersection\n                        and intersection[0] >= (min_x - .5)\n                        and intersection[0] <= (max_x + .5)\n                        and intersection[1] >= (min_y - .5)\n                        and intersection[1] <= (max_y + .5)):\n                    points.append(intersection)\n            draw_lines.append(points)\n            draw_color.append(line.grid)\n\n        points_x = [(this_cos * (x - self.base_point[0] + .5)\n                     + self.base_point[0])\n                    for x in np.arange(min_x, max_x)]\n        points_y = [(this_sin * (y - self.base_point[1] + .5)\n                     + self.base_point[1])\n                    for y in np.arange(min_y, max_y)]\n        points_label = [self.determine_K(this_cos, x, this_sin, y, this_offset)\n                        for x, y in zip(points_x, points_y)]\n\n        X, Y = np.meshgrid(np.arange(min_x, max_x, .1),\n                           np.arange(min_y, max_y, .1))\n        Z = np.zeros(X.shape)\n\n        for i in range(X.shape[0]):\n            for j in range(X.shape[1]):\n                Z[i, j] = self.determine_K(this_cos, X[i, j],\n                                           this_sin, Y[i, j],\n                                           this_offset)\n\n        colors = [self.grid_colors[g] for g in draw_color]\n\n        cmap = mpl.cm.viridis\n        bounds = np.unique(Z)\n        norm = mpl.colors.BoundaryNorm(bounds, cmap.N)\n\n        ax.pcolor(X, Y, Z, norm=norm, cmap=cmap)\n\n        ax.add_collection(LineCollection(draw_lines, colors=colors))\n        for x, y, l in zip(points_x, points_y, points_label):\n            ax.text(x, y, f'{l:.0f}')\n\n        ax.set_xlim(min_x, max_x)\n        ax.set_ylim(min_y, max_y)\n        ax.set_aspect('equal')\n        return ax\n\n    def draw_all_tiles(self, ax):\n        \"\"\"Draws all the tiles\"\"\"\n        min_x = np.inf\n        max_x = -np.inf\n        min_y = np.inf\n        max_y = -np.inf\n\n        polygons = []\n        polygon_colors = []\n        for t in self.tiles.values():\n            locations = []\n            for p in t.tile_points:\n                locations.append(p.base_location)\n                if min_x > p.base_location[0]:\n                    min_x = p.base_location[0]\n                if max_x < p.base_location[0]:\n                    max_x = p.base_location[0]\n                if min_y > p.base_location[1]:\n                    min_y = p.base_location[1]\n                if max_y < p.base_location[1]:\n                    max_y = p.base_location[1]\n\n            polygons.append(locations)\n            polygon_colors.append(self.colors[t.tile_group])\n\n        polygon_collection = PolyCollection(polygons,\n                                            facecolor=polygon_colors,\n                                            edgecolor=self.colors[-1])\n        ax.add_collection(polygon_collection)\n        ax.set_aspect('equal')\n        ax.set_xlim(min_x, max_x)\n        ax.set_ylim(min_y, max_y)\n```\n:::\n\n\n::: {layout-ncol=\"3\"}\n![Offsets](offsets_graph.png)\n\n![K=1 Grid](k_1_graph.png)\n\n![K=3 Grid](k_3_graph.png)\n:::\n\n::: {layout-ncol=\"2\"}\n![All tiles](all_tiles_graph.png)\n\n![Connected Tiles](connected_tiles_graph.png)\n:::\n\n<br>\n<hr>\n<center>\n<h2>Example</h2>\n</center>\n<hr>\n\n::: {#7aa1d57b .cell execution_count=7}\n``` {.python .cell-code}\nimport grid_tilings\nimport matplotlib.pyplot as plt\n\n\nmg = grid_tilings.Multigrid(seed=0,\n                            grid_count=5,\n                            grid_bounds=[-5, 5],\n                            rotation=0,\n                            base_point = [0, 0],\n                            offsets=[.2, .2, .2, .2, .2])\nmg.create_tiles()\n\nfig, ax = plt.subplots(figsize=(5, 5))\nax = mg.draw_image(ax)\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n![Final Image](image_graph.png)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}