{
  "hash": "cb3d927bcfea1015ac0a0e2cef0121b9",
  "result": {
    "markdown": "---\ntitle: \"Pandemic Mazes\"\ndescription: \"Generative art based on grocery store floor signs\"\ndate: \"2022-05-03\"\ncategories: [R, Generative Art]\nimage: \"image_75_1.jpeg\"\nexecute: \n  eval: false\n---\n\n\n<hr>\n<center><h2>Background</h2></center>\n<hr>\n\nThis art project came out of my experiences during the pandemic. I thought the signs on grocery store floors were an interesting physical manifestation of the COVID rules. Especially since some places had clear signs but some didn't, some people followed the signs but some didn't, and some signs were consistent for a long time but some weren't. This same situation is reflected in the other rules where some are clear, followed, and consistent, but others aren't. \n\nSo I decided to make a generative art project that creates random paths based on pandemic signs. For each image created, the maze generated has the same start and endpoints, but the path in between can be complicated or straightforward. On one end of the spectrum, the maze follows mostly straight lines into the middle and then back out of the maze with consistent signage. The other end has the maze meander all over with many different signs. There's a parameter for all of this code that causes that. Changes in this parameter can express experiences or match data for different regions/times.\n\nThe program works in five steps:\n\n* Create a base maze\n* Update the maze to double all the edges\n* Move through all edges in one path\n* Add in the images for signs\n* Finally, add the background and save\n\n<hr>\n<center><h2>Create a base maze</h2></center>\n<hr>\n\nA five-by-five square of nodes sets up each maze. A data set of edges connect the vertical and horizontal neighbors. The set for the labyrinth is marked here. The maze always starts at the bottom middle node. After that, edges are selected, checked if they can be included or if it would cause the maze to connect in on itself, and marked as part of the maze or as discard. \n\nA parameter ranging from 0 to 1 determines how much the maze turns. A value of 0 yields a completely random maze and 1 for following a smooth labyrinth that spirals in and then back out to the start. Any value in between sets the probability of choosing a new step at random versus moving along the labyrinth.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"[`get_maze` function]\"}\nget_maze <- function(structure_parameter) {\n\n  # Sets up base data set of potential edges for the maze\n  # size is always 5 for right now\n  size <- 5\n  edges <- CJ(\n    x1 = rep(seq(1, size), 2),\n    y1 = seq(1, size)\n  )\n  edges[, \":=\"(x2 = ifelse(.I %% 2 == 0, x1 + 1, x1),\n    y2 = ifelse(.I %% 2 == 1, y1 + 1, y1))]\n  edges <- edges[x2 <= size & y2 <= size, ]\n  edges[, id := seq(1, nrow(edges))]\n  edges[, \":=\"(node1 = (x1 - 1) * size + (y1 - 1) + 1,\n    node2 = (x2 - 1) * size + (y2 - 1) + 1)]\n  setkey(edges, id)\n\n  # Set up the path for the labyrinth\n  edges[, labyrinth := 0]\n  edges[\n    .(c(20, 29, 37, 38, 39, 40, \n        36, 27, 18,  9,  7,  5, \n         3,  1,  2, 10, 12, 14, \n        17, 26, 32, 30, 22, 21)),\n    labyrinth := seq(1, 24)\n  ]\n\n  # data set of nodes\n  nodes <- unique(rbind(edges[, .(id = node1)], edges[, .(id = node2)]))\n  nodes[, connected := 0]\n  setkey(nodes, id)\n\n  # data set of node id to edge ids\n  nodes_edges <- unique(rbind(edges[, .(id = node1, edge = id)][], \n                              edges[, .(id = node2, edge = id)]))\n  setkey(nodes_edges, id)\n\n  # location : 1 for maze, 0 for frontier, -1 for uncharted, -2 for discarded\n  # starting point : bottom middle\n  # include bottom middle then either off to the sides or up\n  if (runif(1, 0, 1) <= structure_parameter) {\n    starting_edge <- edges[x1 == 3 & y1 == 1 & x2 == 4 & y2 == 1, ]\n  } else {\n    starting_edge <- edges[(x1 == 3 & y1 == 1) |\n      (x1 == 2 & y1 == 1 & x2 == 3 & y2 == 1), ][sample(.N, 1), ]\n  }\n\n  # Set up base columns\n  edges[, \":=\"(location = -1,\n    probability = 0)]\n  edges[.(starting_edge$id), \":=\"(location = 1,\n    probability = 0)]\n  nodes[.(c(starting_edge$node1, starting_edge$node2)), connected := 1]\n  edges[.(nodes_edges[.(c(starting_edge$node1, starting_edge$node2)), \"edge\"]), \":=\"\n  (location = fifelse(location == -1, 0, location),\n    probability = fifelse(location == -1, 1, probability))]\n\n  #### Loop through maze generation ----\n  num_edges <- 1\n  while (num_edges < (size^2 - 1)) {\n\n    # select next edge\n    if (runif(1, 0, 1) <= structure_parameter) {\n      selected_edge <- edges[edges$location == 0, \n                             ][max(labyrinth) == labyrinth, \n                               ][sample(.N, 1), ]\n    } else {\n      selected_edge <- edges[sample(.N, 1, prob = probability), ]\n    }\n\n    ## if it's good, then\n    # add it to the maze\n    # add connecting edges to the frontier\n    # else add it to discard\n    if (any(nodes[.(c(selected_edge$node1, selected_edge$node2))\n                  , connected] == 0)) {\n\n      # add to maze\n      edges[.(selected_edge$id), \":=\"(location = 1,\n        probability = 0)]\n\n      # update nodes\n      nodes[.(c(selected_edge$node1, selected_edge$node2)), connected := 1]\n\n      # update frontier\n      edges[.(nodes_edges[.(c(selected_edge$node1, selected_edge$node2))\n                          , \"edge\"]), \":=\"\n      (location = fifelse(location == -1, 0, location),\n        probability = fifelse(location == -1, 1, probability))]\n\n      num_edges <- num_edges + 1\n    } else {\n      # drop from frontier\n      edges[.(selected_edge$id), \":=\"(location = -2,\n        probability = 0)]\n    }\n  }\n\n  return(edges[location == 1, ])\n}\n```\n:::\n\n\nThe following image displays the base maze layout. The edges are numbered with their x1/y1 coordinates at their left/bottom and x2/y2 at their right/top. The labyrinth pattern is highlighted in blue.\n\n![Maze edges with labyrinth highlighted](post_1.png)\n\n<hr>\n<center><h2>Update the maze to double all the edges</h2></center>\n<hr>\n\nFor the final image, the path needs to start at one point, move through all the nodes, then exit at one other point. To ensure this capability, the path will travel through the maze and backtrack to the starting point. This is typically done using a graph setup, but I wanted to keep the table data structure. So instead of following those instructions, I take every edge and double for each direction. The code works by replacing all possible edges with either two parallel edges (if the edge was in the maze) or two perpendicular ones (if the edge was discarded).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"[`update_maze` function]\"}\nupdate_maze <- function(edges) {\n\n  # list out all possible edges\n  # (basically same code as setting up the maze)\n  # plus adds edges that stick out on the outside\n  all_possible_edges <- CJ(\n    x1 = rep(seq(1, 6), 2) - 1,\n    y1 = seq(1, 6) - 1\n  )\n  all_possible_edges[, \":=\"(x2 = ifelse(.I %% 2 == 0, x1 + 1, x1),\n    y2 = ifelse(.I %% 2 == 1, y1 + 1, y1))]\n  all_possible_edges <- all_possible_edges[(x1 != 0 | x2 != 0) &\n    (y1 != 0 | y2 != 0), ]\n\n  edges <- edges[, .(x1, x2, y1, y2, id)]\n\n  # merge maze and all possible edges to see which ones weren't used\n  all_possible_edges <- merge(all_possible_edges, edges,\n    by = c(\"x1\", \"y1\", \"x2\", \"y2\"),\n    all.x = TRUE\n  )\n\n  # This function subs in the new edges appropriately\n  # basically, any path edge needs to be updated to two edges so the maze\n  # starts at the bottom middle, travels through the maze, and back to the start\n  create_new_edges <- function(x1, y1, x2, y2, id) {\n    # if no edges, add block\n    if (is.na(id)) {\n      if (y1 == y2) { # horizontal edge\n        list(\n          x1_1 = 2 * x1,\n          y1_1 = 2 * y1 - 1,\n          x2_1 = 2 * x1,\n          y2_1 = 2 * y1,\n          x1_2 = 2 * x2 - 1,\n          y1_2 = 2 * y2 - 1,\n          x2_2 = 2 * x2 - 1,\n          y2_2 = 2 * y2\n        )\n      } else { # vertical edge\n        list(\n          x1_1 = 2 * x1 - 1,\n          y1_1 = 2 * y1,\n          x2_1 = 2 * x1,\n          y2_1 = 2 * y1,\n          x1_2 = 2 * x2 - 1,\n          y1_2 = 2 * y2 - 1,\n          x2_2 = 2 * x2,\n          y2_2 = 2 * y2 - 1\n        )\n      }\n    } else { # has edge, add connections\n      if (y1 == y2) { # horizontal edge\n        list(\n          x1_1 = 2 * x1,\n          y1_1 = 2 * y1 - 1,\n          x2_1 = 2 * x2 - 1,\n          y2_1 = 2 * y2 - 1,\n          x1_2 = 2 * x1,\n          y1_2 = 2 * y1,\n          x2_2 = 2 * x2 - 1,\n          y2_2 = 2 * y2\n        )\n      } else { # vertical edge\n        list(\n          x1_1 = 2 * x1 - 1,\n          y1_1 = 2 * y1,\n          x2_1 = 2 * x2 - 1,\n          y2_1 = 2 * y2 - 1,\n          x1_2 = 2 * x1,\n          y1_2 = 2 * y1,\n          x2_2 = 2 * x2,\n          y2_2 = 2 * y2 - 1\n        )\n      }\n    }\n  }\n\n  # fill in blocks and paths\n  all_possible_edges[, c(\n    \"x1_1\", \"y1_1\", \"x2_1\", \"y2_1\",\n    \"x1_2\", \"y1_2\", \"x2_2\", \"y2_2\"\n  ) := create_new_edges(x1, y1, x2, y2, id),\n  by = seq_len(nrow(all_possible_edges))\n  ]\n\n  # clean everything up\n  all_possible_edges[, \":=\"(x1 = NULL,\n    y1 = NULL,\n    x2 = NULL,\n    y2 = NULL,\n    id = NULL)]\n\n  all_possible_edges <- melt(all_possible_edges,\n    measure.vars = patterns(\"x1\", \"y1\", \"x2\", \"y2\"),\n    value.name = c(\"x1\", \"y1\", \"x2\", \"y2\")\n  )[, variable := NULL]\n\n  all_possible_edges <- all_possible_edges[(x1 > 0 &\n    y1 > 0 &\n    x2 < 11 &\n    y2 < 11) &\n    (x1 != 5 |\n      y1 != 1 |\n      x2 != 6 |\n      y2 != 1), ]\n\n  all_possible_edges <- rbind(\n    all_possible_edges,\n    data.table(\n      x1 = c(5, 6),\n      y1 = c(0, 0),\n      x2 = c(5, 6),\n      y2 = c(1, 1)\n    )\n  )\n}\n```\n:::\n\n\nThe following two images show a randomly generated maze and output for doubling the edges. The image on the left has the maze in red with all possible edges in blue. Note the extra blue edges are pointing out of the original five-by-five square. These will provide the walls for paths on the maze's outside edge. The image on the right displays the result of substituting every edge with a parallel set for maze edges and a perpendicular set for non-maze edges. So, each red line has two new black lines running next to it, while each blue line has two new black lines cutting through it. Note that the coordinates' ranges have changed from one to five to zero to eleven (everything is times two then minus one).\n\n::: {layout-ncol=\"2\"}\n![Randomly generated maze](post_2.png)\n\n![Doubling maze edges](post_3.png)\n:::\n\nThis image shows the cleaned-up final output for this function. The unconnected outside edges are removed. The start and end edges are added to the bottom middle with the connection between them severed. \n\n![Cleaned-up output](post_4.png)\n\n<hr>\n<center><h2>Move through all edges in one path</h2></center>\n<hr>\n\nNow, the edges from the previous step can be connected into one path. The path starts at the bottom middle and then moves to the next node. After that, the path connects to the unconnected node. Because of the previous setup, each node (except starting and end ones) connects to exactly two other nodes. So, we don't have to worry about hitting dead ends.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"[`maze_to_path` function]\"}\nmaze_to_path <- function(edges) {\n  # set up id\n  edges[, id := .I]\n  setkey(edges, id)\n\n  # set up nodes data set\n  nodes <- unique(rbind(edges[, .(x = x1, y = y1)]\n                        , edges[, .(x = x2, y = y2)]))\n  nodes[, id := .I]\n  setkey(nodes, id)\n\n  # add node ids to edges data set\n  edges <- merge(edges, nodes,\n    by.x = c(\"x1\", \"y1\"), by.y = c(\"x\", \"y\"),\n    suffixes = c(\"\", \"_node_1\"), all.x = TRUE\n  )\n  edges <- merge(edges, nodes,\n    by.x = c(\"x2\", \"y2\"), by.y = c(\"x\", \"y\"),\n    suffixes = c(\"\", \"_node_2\"), all.x = TRUE\n  )\n\n  # nodes to edges look up table\n  nodes_edges <- unique(rbind(\n    edges[, .(id = id_node_1, edge = id, connecting_node = id_node_2)],\n    edges[, .(id = id_node_2, edge = id, connecting_node = id_node_1)]\n  ))\n  setkey(nodes_edges, id)\n\n  # save spot for path\n  path <- vector(mode = \"numeric\")\n\n  # variables to keep track of progress through the mase\n  last_node <- nodes[y == 0 & x == 5, id]\n  current_node <- nodes[y == 0 & x == 6, id]\n\n  # update path\n  path <- append(path, current_node)\n  previous_node <- current_node\n\n  # keep going to unexplored nodes\n  current_node <- nodes_edges[.(current_node), \n                              ][connecting_node != previous_node\n                                , connecting_node]\n\n  # continue through the whole path\n  while (length(current_node) > 0) {\n    path <- append(path, current_node)\n    future_node <- nodes_edges[.(current_node), \n                               ][connecting_node != previous_node\n                                 , connecting_node]\n    previous_node <- current_node\n    current_node <- future_node\n  }\n\n  path <- data.table(\n    order = seq(1, length(path)),\n    node = path\n  )\n  path <- merge(path, nodes, by.x = c(\"node\"), by.y = c(\"id\"))\n}\n```\n:::\n\n\n<hr>\n<center><h2>Add in the images for signs</h2></center>\n<hr>\n\nCreating the signs takes place before creating the maze. Each image name has three parts: sign, course, and direction. The sign contains essential information on what the image is. The course is how the path moves (straight, turn right, etc.). Direction is where the path is coming from (east,  north, etc.). \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"[first part of `create_signs` code]\"}\nlibrary(data.table)\nlibrary(ggplot2)\n\n# do not enter\nggplot() +\n  geom_polygon(aes(\n    x = cos(seq(0, 2 * pi, pi / 4) + pi / 8) * 1.082,\n    y = sin(seq(0, 2 * pi, pi / 4) + pi / 8) * 1.082\n  ), color = \"#90091E\", fill = \"#90091E\") +\n  geom_text(aes(x = 0, y = 0, label = \"DO NOT\\nENTER\"), \n            color = \"white\", size = 3) +\n  scale_x_continuous(limits = c(-1, 1)) +\n  scale_y_continuous(limits = c(-1, 1)) +\n  theme_void() +\n  coord_equal()\nggsave(paste0(\"signs/do_not_enter_straight_south.png\"),\n  height = 1,\n  width = 1\n)\n```\n:::\n\n\nYou can see the rest of the code here.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"[second part of `create_signs` code]\"}\ndirections <- data.table(\n  direction = c(\n    \"east\",\n    \"north\",\n    \"west\",\n    \"south\"\n  ),\n  angle = c(270, 0, 90, 180)\n)\n\ncircle <- data.table(\n  x = cos(seq(0, 2 * pi, length.out = 360)),\n  y = sin(seq(0, 2 * pi, length.out = 360))\n)\n\n# square\nsquare <- data.table(\n  x = c(-1, 1, 1, -1),\n  y = c(-1, -1, 1, 1)\n)\n\n# diamond\ndiamond <- data.table(\n  x = c(0, 1, 0, -1),\n  y = c(-1, 0, 1, 0)\n)\n\nfor (i in 1:nrow(directions)) {\n  current_direction <- directions[i, direction]\n  current_angle <- directions[i, angle]\n\n  # light green dot\n  ggplot() +\n    geom_polygon(data = circle, aes(x = x * .5, y = y * .5), \n                 color = \"#6FBD4B\", fill = \"#6FBD4B\") +\n    scale_x_continuous(limits = c(-1, 1)) +\n    scale_y_continuous(limits = c(-1, 1)) +\n    theme_void() +\n    coord_equal()\n  ggsave(paste0(\"signs/light_green_dot_straight_\", \n                current_direction, \".png\"),\n    height = 1,\n    width = 1\n  )\n\n  # dark green dot\n  ggplot() +\n    geom_polygon(data = circle, aes(x = x * .75, y = y * .75), \n                 color = \"#235C09\", fill = \"#235C09\") +\n    scale_x_continuous(limits = c(-1, 1)) +\n    scale_y_continuous(limits = c(-1, 1)) +\n    theme_void() +\n    coord_equal()\n  ggsave(paste0(\"signs/dark_green_dot_straight_\", \n                current_direction, \".png\"),\n    height = 1,\n    width = 1\n  )\n\n  # yellow tape\n  if (current_direction %in% c(\"north\", \"south\")) {\n    ggplot() +\n      geom_rect(aes(\n        xmin = -.5, ymin = -.075,\n        xmax = .5, ymax = .075\n      ),\n      color = \"#EDE24C\",\n      fill = \"#EDE24C\"\n      ) +\n      scale_x_continuous(limits = c(-1, 1)) +\n      scale_y_continuous(limits = c(-1, 1)) +\n      theme_void() +\n      coord_equal()\n    ggsave(paste0(\"signs/yellow_tape_straight_\", \n                  current_direction, \".png\"),\n      height = 1,\n      width = 1\n    )\n  } else {\n    ggplot() +\n      geom_rect(aes(\n        xmin = -.075, ymin = -.5,\n        xmax = .075, ymax = .5\n      ),\n      color = \"#EDE24C\",\n      fill = \"#EDE24C\"\n      ) +\n      scale_x_continuous(limits = c(-1, 1)) +\n      scale_y_continuous(limits = c(-1, 1)) +\n      theme_void() +\n      coord_equal()\n    ggsave(paste0(\"signs/yellow_tape_straight_\", \n                  current_direction, \".png\"),\n      height = 1,\n      width = 1\n    )\n  }\n\n  # wait here\n  ggplot() +\n    geom_polygon(data = square, aes(x = x, y = y), \n                 color = \"#4D8235\", fill = \"#4D8235\") +\n    geom_text(aes(x = 0, y = 0, label = \"WAIT\\nHERE\"),\n      color = \"white\", size = 6,\n      angle = current_angle\n    ) +\n    scale_x_continuous(limits = c(-1, 1)) +\n    scale_y_continuous(limits = c(-1, 1)) +\n    theme_void() +\n    coord_equal()\n  ggsave(paste0(\"signs/wait_here_straight_\", \n                current_direction, \".png\"),\n    height = 1,\n    width = 1\n  )\n\n  for (turn in c(\"right\", \"left\")) {\n    ggplot() +\n      geom_polygon(data = square, aes(x = x, y = y), \n                   color = \"#4D8235\", fill = \"#4D8235\") +\n      geom_text(aes(x = 0, y = 0, label = \"WAIT\\nHERE\"),\n        color = \"white\", size = 6,\n        angle = current_angle\n      ) +\n      scale_x_continuous(limits = c(-1, 1)) +\n      scale_y_continuous(limits = c(-1, 1)) +\n      theme_void() +\n      coord_equal()\n    ggsave(paste0(\"signs/wait_here_\", turn, \"_\", \n                  current_direction, \".png\"),\n      height = 1,\n      width = 1\n    )\n  }\n\n  # wash your hands\n  ggplot() +\n    geom_polygon(data = circle, aes(x = x, y = y), \n                 color = \"#4D4D7A\", fill = \"#4D4D7A\") +\n    geom_text(aes(x = 0, y = 0, label = \"WASH YOUR\\nHANDS\"),\n      color = \"white\", size = 3,\n      angle = current_angle\n    ) +\n    scale_x_continuous(limits = c(-1, 1)) +\n    scale_y_continuous(limits = c(-1, 1)) +\n    theme_void() +\n    coord_equal()\n  ggsave(paste0(\"signs/wash_your_hands_straight_\", \n                current_direction, \".png\"),\n    height = 1,\n    width = 1\n  )\n\n  for (turn in c(\"right\", \"left\")) {\n    ggplot() +\n      geom_polygon(data = circle, aes(x = x, y = y), \n                   color = \"#4D4D7A\", fill = \"#4D4D7A\") +\n      geom_text(aes(x = 0, y = 0, label = \"WASH YOUR\\nHANDS\"),\n        color = \"white\", size = 3,\n        angle = current_angle\n      ) +\n      scale_x_continuous(limits = c(-1, 1)) +\n      scale_y_continuous(limits = c(-1, 1)) +\n      theme_void() +\n      coord_equal()\n    ggsave(paste0(\"signs/wash_your_hands_\", turn, \"_\", \n                  current_direction, \".png\"),\n      height = 1,\n      width = 1\n    )\n  }\n\n  # wear a mask\n  ggplot() +\n    geom_polygon(data = circle, aes(x = x, y = y), \n                 color = \"#538479\", fill = \"#538479\") +\n    geom_text(aes(x = 0, y = 0, label = \"WEAR A\\nMASK\"),\n      color = \"white\", size = 3,\n      angle = current_angle\n    ) +\n    scale_x_continuous(limits = c(-1, 1)) +\n    scale_y_continuous(limits = c(-1, 1)) +\n    theme_void() +\n    coord_equal()\n  ggsave(paste0(\"signs/wear_a_mask_straight_\", \n                current_direction, \".png\"),\n    height = 1,\n    width = 1\n  )\n\n  for (turn in c(\"right\", \"left\")) {\n    ggplot() +\n      geom_polygon(data = circle, aes(x = x, y = y), \n                   color = \"#538479\", fill = \"#538479\") +\n      geom_text(aes(x = 0, y = 0, label = \"WEAR A\\nMASK\"),\n        color = \"white\", size = 3,\n        angle = current_angle\n      ) +\n      scale_x_continuous(limits = c(-1, 1)) +\n      scale_y_continuous(limits = c(-1, 1)) +\n      theme_void() +\n      coord_equal()\n    ggsave(paste0(\"signs/wear_a_mask_\", turn, \"_\", \n                  current_direction, \".png\"),\n      height = 1,\n      width = 1\n    )\n  }\n\n  # wait six feet\n  ggplot() +\n    geom_polygon(data = circle, aes(x = x, y = y), \n                 color = \"#54707C\", fill = \"#54707C\") +\n    geom_text(aes(x = 0, y = 0, label = \"WAIT \\nSIX FEET\"),\n      color = \"white\", size = 3,\n      angle = current_angle\n    ) +\n    scale_x_continuous(limits = c(-1, 1)) +\n    scale_y_continuous(limits = c(-1, 1)) +\n    theme_void() +\n    coord_equal()\n  ggsave(paste0(\"signs/wait_six_feet_straight_\", \n                current_direction, \".png\"),\n    height = 1,\n    width = 1\n  )\n\n  for (turn in c(\"right\", \"left\")) {\n    ggplot() +\n      geom_polygon(data = circle, aes(x = x, y = y), \n                   color = \"#54707C\", fill = \"#54707C\") +\n      geom_text(aes(x = 0, y = 0, label = \"WAIT \\nSIX FEET\"),\n        color = \"white\", size = 3,\n        angle = current_angle\n      ) +\n      scale_x_continuous(limits = c(-1, 1)) +\n      scale_y_continuous(limits = c(-1, 1)) +\n      theme_void() +\n      coord_equal()\n    ggsave(paste0(\"signs/wait_six_feet_\", turn, \"_\", \n                  current_direction, \".png\"),\n      height = 1,\n      width = 1\n    )\n  }\n\n  # 6 feet\n  if (current_direction %in% c(\"north\", \"south\")) {\n    ggplot() +\n      geom_polygon(data = diamond, aes(x = x, y = y), \n                   color = \"#E1AD0F\", fill = \"#E1AD0F\") +\n      geom_text(aes(x = 0, y = 0, label = \"6 FEET\"),\n        color = \"black\", size = 3,\n        angle = current_angle\n      ) +\n      geom_segment(aes(\n        x = 0,\n        y = c(.25, -.25),\n        xend = 0,\n        yend = c(.8, -.8)\n      ),\n      lineend = \"butt\",\n      linejoin = \"mitre\",\n      color = \"black\",\n      arrow = arrow(length = unit(0.05, \"npc\"), \n                    angle = 45, type = \"closed\"),\n      size = 2\n      ) +\n      scale_x_continuous(limits = c(-1, 1)) +\n      scale_y_continuous(limits = c(-1, 1)) +\n      theme_void() +\n      coord_equal()\n    ggsave(paste0(\"signs/six_feet_straight_\", \n                  current_direction, \".png\"),\n      height = 1,\n      width = 1\n    )\n  } else {\n    ggplot() +\n      geom_polygon(data = diamond, aes(x = x, y = y), \n                   color = \"#E1AD0F\", fill = \"#E1AD0F\") +\n      geom_text(aes(x = 0, y = 0, label = \"6 FEET\"),\n        color = \"black\", size = 3,\n        angle = current_angle\n      ) +\n      geom_segment(aes(\n        x = c(.25, -.25),\n        y = 0,\n        xend = c(.8, -.8),\n        yend = 0\n      ),\n      lineend = \"butt\",\n      linejoin = \"mitre\",\n      color = \"black\",\n      arrow = arrow(length = unit(0.05, \"npc\"), \n                    angle = 45, type = \"closed\"),\n      size = 2\n      ) +\n      scale_x_continuous(limits = c(-1, 1)) +\n      scale_y_continuous(limits = c(-1, 1)) +\n      theme_void() +\n      coord_equal()\n    ggsave(paste0(\"signs/six_feet_straight_\", \n                  current_direction, \".png\"),\n      height = 1,\n      width = 1\n    )\n  }\n\n  # one way\n  ggplot() +\n    geom_polygon(data = square, aes(x = x, y = y), \n                 color = \"#AB4343\", fill = \"#AB4343\") +\n    geom_text(aes(x = 0, y = 0, label = \"ONE\\nWAY\"),\n      color = \"white\", size = 6,\n      angle = current_angle\n    ) +\n    scale_x_continuous(limits = c(-1, 1)) +\n    scale_y_continuous(limits = c(-1, 1)) +\n    theme_void() +\n    coord_equal()\n  ggsave(paste0(\"signs/one_way_straight_\", \n                current_direction, \".png\"),\n    height = 1,\n    width = 1\n  )\n\n  for (turn in c(\"right\", \"left\")) {\n    ggplot() +\n      geom_polygon(data = square, aes(x = x, y = y), \n                   color = \"#AB4343\", fill = \"#AB4343\") +\n      geom_text(aes(x = 0, y = 0, label = \"ONE\\nWAY\"),\n        color = \"white\", size = 6,\n        angle = current_angle\n      ) +\n      scale_x_continuous(limits = c(-1, 1)) +\n      scale_y_continuous(limits = c(-1, 1)) +\n      theme_void() +\n      coord_equal()\n    ggsave(paste0(\"signs/one_way_\", turn, \"_\", \n                  current_direction, \".png\"),\n      height = 1,\n      width = 1\n    )\n  }\n}\n\n# arrow\nggplot() +\n  geom_polygon(aes(\n    x = c(-.25, .25, .25, .5, 0, -.5, -.25),\n    y = c(-.9, -.9, .25, .25, .9, .25, .25)\n  ), color = \"#444444\", fill = \"#444444\") +\n  scale_x_continuous(limits = c(-1, 1)) +\n  scale_y_continuous(limits = c(-1, 1)) +\n  theme_void() +\n  coord_equal()\nggsave(paste0(\"signs/arrow_straight_north.png\"),\n  height = 1,\n  width = 1\n)\nggsave(paste0(\"signs/arrow_right_north.png\"),\n  height = 1,\n  width = 1\n)\nggsave(paste0(\"signs/arrow_left_north.png\"),\n  height = 1,\n  width = 1\n)\n\nggplot() +\n  geom_polygon(aes(\n    x = c(-.25, .25, .25, .5, 0, -.5, -.25),\n    y = c(.9, .9, -.25, -.25, -.9, -.25, -.25)\n  ), color = \"#444444\", fill = \"#444444\") +\n  scale_x_continuous(limits = c(-1, 1)) +\n  scale_y_continuous(limits = c(-1, 1)) +\n  theme_void() +\n  coord_equal()\nggsave(paste0(\"signs/arrow_straight_south.png\"),\n  height = 1,\n  width = 1\n)\nggsave(paste0(\"signs/arrow_right_south.png\"),\n  height = 1,\n  width = 1\n)\nggsave(paste0(\"signs/arrow_left_south.png\"),\n  height = 1,\n  width = 1\n)\n\nggplot() +\n  geom_polygon(aes(\n    x = c(-.9, -.9, .25, .25, .9, .25, .25),\n    y = c(-.25, .25, .25, .5, 0, -.5, -.25)\n  ), color = \"#444444\", fill = \"#444444\") +\n  scale_x_continuous(limits = c(-1, 1)) +\n  scale_y_continuous(limits = c(-1, 1)) +\n  theme_void() +\n  coord_equal()\nggsave(paste0(\"signs/arrow_straight_east.png\"),\n  height = 1,\n  width = 1\n)\nggsave(paste0(\"signs/arrow_right_east.png\"),\n  height = 1,\n  width = 1\n)\nggsave(paste0(\"signs/arrow_left_east.png\"),\n  height = 1,\n  width = 1\n)\n\nggplot() +\n  geom_polygon(aes(\n    x = c(.9, .9, -.25, -.25, -.9, -.25, -.25),\n    y = c(-.25, .25, .25, .5, 0, -.5, -.25)\n  ),\n  color = \"#444444\", fill = \"#444444\"\n  ) +\n  scale_x_continuous(limits = c(-1, 1)) +\n  scale_y_continuous(limits = c(-1, 1)) +\n  theme_void() +\n  coord_equal()\nggsave(paste0(\"signs/arrow_straight_west.png\"),\n  height = 1,\n  width = 1\n)\nggsave(paste0(\"signs/arrow_right_west.png\"),\n  height = 1,\n  width = 1\n)\nggsave(paste0(\"signs/arrow_left_west.png\"),\n  height = 1,\n  width = 1\n)\n```\n:::\n\n\nWe'll need to determine how the path moves and which images display that to add the images. Using information from the previous and next steps, we can determine which direction the path moves and whether it turns or stays straight. This data can be paired with information from the image names to choose images that fit in the maze.\n\nFor each node on the path, several images could work. So, we select one at random from a bag. A parameter determines the number of available images in the bag. A value of 0 has all possible images on each draw. A value of 1 only yields one image for each course (straight vs. turn).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"[`get_image_data` function]\"}\nget_image_data <- function(path, structure_parameter) {\n\n  # Set up variables used to determine which images can be used\n  path <- path[order(order), ]\n  path[, \":=\"(previous_x = shift(x, type = \"lag\"),\n    previous_y = shift(y, type = \"lag\"),\n    next_x = shift(x, type = \"lead\"),\n    next_y = shift(y, type = \"lead\"))]\n\n  path[, \":=\"(course = fifelse(\n    previous_x == next_x | previous_y == next_y, \"straight\",\n    fifelse((y > previous_y & next_x > x) |\n      (x > previous_x & next_y < y) |\n      (y < previous_y & next_x < x) |\n      (x < previous_x & next_y > y), \"right\", \"left\")\n  ),\n  direction = fifelse(\n    x < next_x, \"east\",\n    fifelse(\n      y < next_y, \"north\",\n      fifelse(\n        x > next_x, \"west\",\n        \"south\"\n      )\n    )\n  ))]\n\n  # set up bag to hold the images\n  bag_pull <- function(this_course, this_direction, bag) {\n    bag[course == this_course & direction == this_direction, \n        ][sample(.N, 1), file]\n  }\n\n  # fill bag\n  bag <- data.table(file = list.files(\"signs\", full.names = TRUE))\n  bag <- bag[file != \"signs/do_not_enter_straight_south.png\", ]\n\n  bag[, c(\"sign\", \"direction\") := \n        tstrsplit(gsub(\"signs/|.png\", \"\", file), \"_(?!.*_)\", perl = TRUE)]\n  bag[, c(\"sign\", \"course\") := tstrsplit(sign, \"_(?!.*_)\", perl = TRUE)]\n  bag[, \":=\"(sub_course = fifelse(course == \"straight\", \"straight\", \"turn\"))]\n\n  # filter down to a smaller amount if the structure_parameter is large\n  bag_subset <- unique(bag[, c(\"sign\", \"sub_course\")])\n  bag_subset <- unique(bag_subset[\n    , .SD[sample(.N, ceiling(\n      (1 - (structure_parameter)^(1 / 4)) * (.N - 1) + 1))]\n    , by = sub_course][, c(\"sign\", \"sub_course\")])\n  bag <- merge(bag, bag_subset, by = c(\"sign\", \"sub_course\"))\n\n  # add images from bag\n  path[, image := bag_pull(course, direction, bag), by = seq_len(nrow(path))]\n\n  # Start and end\n  path[y == 0 & x == 6, image := \"signs/wait_here_straight_north.png\"]\n  path[y == 0 & x == 5, image := \"signs/do_not_enter_straight_south.png\"]\n}\n```\n:::\n\n\n<hr>\n<center><h2>Finally, add the background and save</h2></center>\n<hr>\n\nAfter setting up the appropriate images, we only need to add a background. The background works by stacking small gray rectangles of various sizes with a low alpha value. This is supposed to resemble a grocery store floor.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\" code-summary=\"[final code]\"}\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(ggimage)\n\nsource(\"get_maze.R\")\nsource(\"update_maze.R\")\nsource(\"maze_to_path.R\")\nsource(\"get_image_data.R\")\n\nset.seed(1)\nfor (structure_parameter in seq(0, 1, by = .25)) {\n  for (num in 1:2) {\n    edges <- get_maze(structure_parameter)\n    edges <- update_maze(edges)\n    path <- maze_to_path(edges)\n    path <- get_image_data(path, structure_parameter)\n\n    # set up background floor\n    floor <- CJ(\n      x = seq(.5, 10.5, length.out = 360),\n      y = seq(-.5, 10.5, length.out = 360)\n    )\n    floor[, color := sample(c(seq(5, 9), c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\")), 1),\n      by = seq_len(nrow(floor))\n    ]\n    floor[, color := paste0(\"#\", color, color, color, color, color, color)]\n    floor[, \":=\"(xmin = x - runif(1, 0, .25),\n      ymin = y - runif(1, 0, .25),\n      xmax = x + runif(1, 0, .25),\n      ymax = y + runif(1, 0, .25)),\n    by = seq_len(nrow(floor))\n    ]\n\n    ggplot() +\n      geom_rect(\n        data = floor,\n        aes(\n          xmin = xmin, ymin = ymin,\n          xmax = xmax, ymax = ymax,\n          fill = color\n        ),\n        color = NA,\n        alpha = .01\n      ) +\n      scale_fill_identity() +\n      geom_image(\n        data = path,\n        aes(x, y, image = image)\n      ) +\n      theme_void() +\n      theme(aspect.ratio = 1)\n    ggsave(paste0(\"output/image_\", structure_parameter * 100, \n                  \"_\", num, \".jpeg\"),\n      width = 8,\n      height = 8,\n      bg = \"#F3F3F3\"\n    )\n  }\n}\n```\n:::\n\n\nNow we can see the final outputs.\n\n::: {layout-ncol=\"2\"}\n![Structure Parameter = 0, Run 1](image_0_1.jpeg)\n\n![Structure Parameter = 0, Run 2](image_0_2.jpeg)\n\n![Structure Parameter = .25, Run 1](image_25_1.jpeg)\n\n![Structure Parameter = .25, Run 2](image_25_2.jpeg)\n\n![Structure Parameter = .5, Run 1](image_50_1.jpeg)\n\n![Structure Parameter = .5, Run 2](image_50_2.jpeg)\n\n![Structure Parameter = .75, Run 1](image_75_1.jpeg)\n\n![Structure Parameter = .75, Run 2](image_75_2.jpeg)\n\n![Structure Parameter = 1, Run 1](image_100_1.jpeg)\n\n![Structure Parameter = 1, Run 2](image_100_2.jpeg)\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}